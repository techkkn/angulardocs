{
  "id": "guide/change-detection-zone-pollution",
  "title": "Resolving zone pollution",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"resolving-zone-pollution\">Resolving zone pollution<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-zone-pollution#resolving-zone-pollution\"><i class=\"material-icons\">link</i></a></h1>\n<p><strong>Zone.js</strong> is a signaling mechanism that Angular uses to detect when an application state might have changed. It captures asynchronous operations like <code>setTimeout</code>, network requests, and event listeners. Angular schedules change detection based on signals from Zone.js.</p>\n<p>In some cases scheduled <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide#tasks\">tasks</a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide#microtasks\">microtasks</a> don’t make any changes in the data model, which makes running change detection unnecessary. Common examples are:</p>\n<ul>\n<li><code>requestAnimationFrame</code>, <code>setTimeout</code> or <code>setInterval</code></li>\n<li>Task or microtask scheduling by third-party libraries</li>\n</ul>\n<p>This section covers how to identify such conditions, and how to run code outside the Angular zone to avoid unnecessary change detection calls.</p>\n<h2 id=\"identifying-unnecessary-change-detection-calls\">Identifying unnecessary change detection calls<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-zone-pollution#identifying-unnecessary-change-detection-calls\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can detect unnecessary change detection calls using Angular DevTools. Often they appear as consecutive bars in the profiler’s timeline with source <code>setTimeout</code>, <code>setInterval</code>, <code>requestAnimationFrame</code>, or an event handler. When you have limited calls within your application of these APIs, the change detection invocation is usually caused by a third-party library.</p>\n<div class=\"lightbox\">\n  <img alt=\"Angular DevTools profiler preview showing Zone pollution\" src=\"generated/images/guide/change-detection/zone-pollution.png\" width=\"1600\" height=\"480\">\n</div>\n<p>In the image above, there is a series of change detection calls triggered by event handlers associated with an element. That’s a common challenge when using third-party, non-native Angular components, which do not alter the default behavior of <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code>.</p>\n<h2 id=\"run-tasks-outside-ngzone\">Run tasks outside <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-zone-pollution#run-tasks-outside-ngzone\"><i class=\"material-icons\">link</i></a></h2>\n<p>In such cases, you can instruct Angular to avoid calling change detection for tasks scheduled by a given piece of code using <a href=\"/api/core/NgZone\">NgZone</a>.</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nclass AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private ngZone: <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>) {}\n  ngOnInit() {\n    this.ngZone.runOutsideAngular(() => setInterval(pollForUpdates), 500);\n  }\n}\n</code-example>\n<p>The preceding snippet instructs Angular to call <code>setInterval</code> outside the Angular Zone and skip running change detection after <code>pollForUpdates</code> runs.</p>\n<p>Third-party libraries commonly trigger unnecessary change detection cycles because they weren't authored with Zone.js in mind. Avoid these extra cycles by calling library APIs outside the Angular zone:</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport * as Plotly from 'plotly.js-dist-min';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nclass AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private ngZone: <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>) {}\n  ngOnInit() {\n    this.ngZone.runOutsideAngular(() => {\n      Plotly.newPlot('chart', data);\n    });\n  }\n}\n</code-example>\n<p>Running <code>Plotly.newPlot('chart', data);</code> within <code>runOutsideAngular</code> instructs the framework that it shouldn’t run change detection after the execution of tasks scheduled by the initialization logic.</p>\n<p>For example, if <code>Plotly.newPlot('chart', data)</code> adds event listeners to a DOM element, Angular does not run change detection after the execution of their handlers.</p>\n\n  <div class=\"reviewed\">Last reviewed on Wed May 04 2022</div>\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/NgZone\n - api/core/Component\n - api/core/NgZone\n - api/core/OnInit\n - guide/change-detection-zone-pollution#identifying-unnecessary-change-detection-calls\n - guide/change-detection-zone-pollution#resolving-zone-pollution\n - guide/change-detection-zone-pollution#run-tasks-outside-ngzone\n - https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide#microtasks\n - https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide#tasks\n-->"
}