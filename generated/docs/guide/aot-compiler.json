{
  "id": "guide/aot-compiler",
  "title": "Ahead-of-time (AOT) compilation",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"ahead-of-time-aot-compilation\">Ahead-of-time (AOT) compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-compilation\"><i class=\"material-icons\">link</i></a></h1>\n<p>An Angular application consists mainly of components and their HTML templates.\nBecause the components and templates provided by Angular cannot be understood by the browser directly, Angular applications require a compilation process before they can run in a browser.</p>\n<p>The Angular <a href=\"guide/glossary#aot\">ahead-of-time (AOT) compiler</a> converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase <em>before</em> the browser downloads and runs that code.\nCompiling your application during the build process provides a faster rendering in the browser.</p>\n<p>This guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.</p>\n<div class=\"alert is-helpful\">\n<p><a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">Watch Alex Rickabaugh explain the Angular compiler</a> at AngularConnect 2019.</p>\n</div>\n<p><a id=\"why-aot\"></a></p>\n<p>Here are some reasons you might want to use AOT.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Reasons</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Faster rendering</td>\n<td align=\"left\">With AOT, the browser downloads a pre-compiled version of the application. The browser loads executable code so it can render the application immediately, without waiting to compile the application first.</td>\n</tr>\n<tr>\n<td align=\"left\">Fewer asynchronous requests</td>\n<td align=\"left\">The compiler <em>inlines</em> external HTML templates and CSS style sheets within the application JavaScript, eliminating separate ajax requests for those source files.</td>\n</tr>\n<tr>\n<td align=\"left\">Smaller Angular framework download size</td>\n<td align=\"left\">There's no need to download the Angular compiler if the application is already compiled. The compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.</td>\n</tr>\n<tr>\n<td align=\"left\">Detect template errors earlier</td>\n<td align=\"left\">The AOT compiler detects and reports template binding errors during the build step before users can see them.</td>\n</tr>\n<tr>\n<td align=\"left\">Better security</td>\n<td align=\"left\">AOT compiles HTML templates and components into JavaScript files long before they are served to the client. With no templates to read and no risky client-side HTML or JavaScript evaluation, there are fewer opportunities for injection attacks.</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"overview\"></a></p>\n<h2 id=\"choosing-a-compiler\">Choosing a compiler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#choosing-a-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular offers two ways to compile your application:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Angular compile</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Just-in-Time (JIT)</td>\n<td align=\"left\">Compiles your application in the browser at runtime. This was the default until Angular 8.</td>\n</tr>\n<tr>\n<td align=\"left\">Ahead-of-Time (AOT)</td>\n<td align=\"left\">Compiles your application and libraries at build time. This is the default starting in Angular 9.</td>\n</tr>\n</tbody>\n</table>\n<p>When you run the <a href=\"cli/build\"><code>ng build</code></a> (build only) or <a href=\"cli/serve\"><code>ng serve</code></a> (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the <code>aot</code> property in your build configuration specified in <code>angular.json</code>.\nBy default, <code>aot</code> is set to <code>true</code> for new CLI applications.</p>\n<p>See the <a href=\"cli\">CLI command reference</a> and <a href=\"guide/build\">Building and serving Angular apps</a> for more information.</p>\n<h2 id=\"how-aot-works\">How AOT works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a></h2>\n<p>The Angular AOT compiler extracts <strong>metadata</strong> to interpret the parts of the application that Angular is supposed to manage.\nYou can specify the metadata explicitly in <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, or implicitly in the constructor declarations of the decorated classes.\nThe metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</p>\n<p>In the following example, the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata object and the class constructor tell Angular how to create and display an instance of <code>TypicalComponent</code>.</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n})\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { â€¦ }\n}\n\n</code-example>\n<p>The Angular compiler extracts the metadata <em>once</em> and generates a <em>factory</em> for <code>TypicalComponent</code>.\nWhen it needs to create a <code>TypicalComponent</code> instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</p>\n<h3 id=\"compilation-phases\">Compilation phases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#compilation-phases\"><i class=\"material-icons\">link</i></a></h3>\n<p>There are three phases of AOT compilation.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">Phase</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">code analysis</td>\n<td align=\"left\">In this phase, the TypeScript compiler and <em>AOT collector</em> create a representation of the source. The collector does not attempt to interpret the metadata it collects. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">code generation</td>\n<td align=\"left\">In this phase, the compiler's <code>StaticReflector</code> interprets the metadata collected in phase 1, performs additional validation of the metadata, and throws an error if it detects a metadata restriction violation.</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">template type checking</td>\n<td align=\"left\">In this optional phase, the Angular <em>template compiler</em> uses the TypeScript compiler to validate the binding expressions in templates. You can enable this phase explicitly by setting the <code>strictTemplates</code> configuration option; see <a href=\"guide/angular-compiler-options\">Angular compiler options</a>.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"metadata-restrictions\">Metadata restrictions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a></h3>\n<p>You write metadata in a <em>subset</em> of TypeScript that must conform to the following general constraints:</p>\n<ul>\n<li>Limit <a href=\"guide/aot-compiler#expression-syntax\">expression syntax</a> to the supported subset of JavaScript</li>\n<li>Only reference exported symbols after <a href=\"guide/aot-compiler#code-folding\">code folding</a></li>\n<li>Only call <a href=\"guide/aot-compiler#supported-functions\">functions supported</a> by the compiler</li>\n<li>Input/Outputs and data-bound class members must be public or protected.</li>\n</ul>\n<p>For additional guidelines and instructions on preparing an application for AOT compilation, see <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular: Writing AOT-friendly applications</a>.</p>\n<div class=\"alert is-helpful\">\n<p>Errors in AOT compilation commonly occur because of metadata that does not conform to the compiler's requirements (as described more fully below).\nFor help in understanding and resolving these problems, see <a href=\"guide/aot-metadata-errors\">AOT Metadata Errors</a>.</p>\n</div>\n<h3 id=\"configuring-aot-compilation\">Configuring AOT compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuring-aot-compilation\"><i class=\"material-icons\">link</i></a></h3>\n<p>You can provide options in the <a href=\"guide/typescript-configuration\">TypeScript configuration file</a> that controls the compilation process.\nSee <a href=\"guide/angular-compiler-options\">Angular compiler options</a> for a complete list of available options.</p>\n<h2 id=\"phase-1-code-analysis\">Phase 1: Code analysis<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-code-analysis\"><i class=\"material-icons\">link</i></a></h2>\n<p>The TypeScript compiler does some of the analytic work of the first phase.\nIt emits the <code>.d.ts</code> <em>type definition files</em> with type information that the AOT compiler needs to generate application code.\nAt the same time, the AOT <strong>collector</strong> analyzes the metadata recorded in the Angular decorators and outputs metadata information in <strong><code>.metadata.json</code></strong> files, one per <code>.d.ts</code> file.</p>\n<p>You can think of <code>.metadata.json</code> as a diagram of the overall structure of a decorator's metadata, represented as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">abstract syntax tree (AST)</a>.</p>\n<div class=\"alert is-helpful\">\n<p>Angular's <a href=\"https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> describes the JSON format as a collection of TypeScript interfaces.</p>\n</div>\n<p><a id=\"expression-syntax\"></a></p>\n<h3 id=\"expression-syntax-limitations\">Expression syntax limitations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax-limitations\"><i class=\"material-icons\">link</i></a></h3>\n<p>The AOT collector only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Syntax</th>\n<th align=\"left\">Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Literal object</td>\n<td align=\"left\"><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td align=\"left\">Literal array</td>\n<td align=\"left\"><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td align=\"left\">Spread in literal array</td>\n<td align=\"left\"><code>['apples', 'flour', ...]</code></td>\n</tr>\n<tr>\n<td align=\"left\">Calls</td>\n<td align=\"left\"><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td align=\"left\">New</td>\n<td align=\"left\"><code>new Oven()</code></td>\n</tr>\n<tr>\n<td align=\"left\">Property access</td>\n<td align=\"left\"><code>pie.slice</code></td>\n</tr>\n<tr>\n<td align=\"left\">Array index</td>\n<td align=\"left\"><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td align=\"left\">Identity reference</td>\n<td align=\"left\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">A template string</td>\n<td align=\"left\"><code>`pie is ${multiplier} times better than cake`</code></td>\n</tr>\n<tr>\n<td align=\"left\">Literal string</td>\n<td align=\"left\"><code>'pi'</code></td>\n</tr>\n<tr>\n<td align=\"left\">Literal number</td>\n<td align=\"left\"><code>3.14153265</code></td>\n</tr>\n<tr>\n<td align=\"left\">Literal boolean</td>\n<td align=\"left\"><code>true</code></td>\n</tr>\n<tr>\n<td align=\"left\">Literal null</td>\n<td align=\"left\"><code>null</code></td>\n</tr>\n<tr>\n<td align=\"left\">Supported prefix operator</td>\n<td align=\"left\"><code>!cake</code></td>\n</tr>\n<tr>\n<td align=\"left\">Supported binary operator</td>\n<td align=\"left\"><code>a+b</code></td>\n</tr>\n<tr>\n<td align=\"left\">Conditional operator</td>\n<td align=\"left\"><code>a ? b : c</code></td>\n</tr>\n<tr>\n<td align=\"left\">Parentheses</td>\n<td align=\"left\"><code>(a+b)</code></td>\n</tr>\n</tbody>\n</table>\n<p>If an expression uses unsupported syntax, the collector writes an error node to the <code>.metadata.json</code> file.\nThe compiler later reports the error if it needs that piece of metadata to generate the application code.</p>\n<div class=\"alert is-helpful\">\n<p>If you want <code>ngc</code> to report syntax errors immediately rather than produce a <code>.metadata.json</code> file with errors, set the <code>strictMetadataEmit</code> option in the TypeScript configuration file.</p>\n<code-example format=\"json\" language=\"json\">\n\n\"angularCompilerOptions\": {\n  â€¦\n  \"strictMetadataEmit\" : true\n}\n\n</code-example>\n<p>Angular libraries have this option to ensure that all Angular <code>.metadata.json</code> files are clean and it is a best practice to do the same when building your own libraries.</p>\n</div>\n<p><a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a></p>\n<h3 id=\"no-arrow-functions\">No arrow functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>The AOT compiler does not support <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\">function expressions</a>\nand <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, also called <em>lambda</em> functions.</p>\n<p>Consider the following component decorator:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  â€¦\n  providers: [{provide: server, useFactory: () => new Server()}]\n})\n\n</code-example>\n<p>The AOT collector does not support the arrow function, <code>() => new Server()</code>, in a metadata expression.\nIt generates an error node in place of the function.\nWhen the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an <em>exported function</em>.</p>\n<p>You can fix the error by converting to this:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  â€¦\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n\n</code-example>\n<p>In version 5 and later, the compiler automatically performs this rewriting while emitting the <code>.js</code> file.</p>\n<p><a id=\"exported-symbols\"></a>\n<a id=\"code-folding\"></a></p>\n<h3 id=\"code-folding\">Code folding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#code-folding\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler can only resolve references to <strong><em>exported</em></strong> symbols.\nThe collector, however, can evaluate an expression during collection and record the result in the <code>.metadata.json</code>, rather than the original expression.\nThis allows you to make limited use of non-exported symbols within expressions.</p>\n<p>For example, the collector can evaluate the expression <code>1 + 2 + 3 + 4</code> and replace it with the result, <code>10</code>.\nThis process is called <em>folding</em>.\nAn expression that can be reduced in this manner is <em>foldable</em>.</p>\n<p><a id=\"var-declaration\"></a></p>\n<p>The collector can evaluate references to module-local <code>const</code> declarations and initialized <code>var</code> and <code>let</code> declarations, effectively removing them from the <code>.metadata.json</code> file.</p>\n<p>Consider the following component definition:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p>The compiler could not refer to the <code>template</code> constant because it isn't exported.\nThe collector, however, can fold the <code>template</code> constant into the metadata definition by in-lining its contents.\nThe effect is the same as if you had written:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p>There is no longer a reference to <code>template</code> and, therefore, nothing to trouble the compiler when it later interprets the <em>collector's</em> output in <code>.metadata.json</code>.</p>\n<p>You can take this example a step further by including the <code>template</code> constant in another expression:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p>The collector reduces this expression to its equivalent <em>folded</em> string:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'\n\n</code-example>\n<h4 id=\"foldable-syntax\">Foldable syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a></h4>\n<p>The following table describes which expressions the collector can and cannot fold:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Syntax</th>\n<th align=\"left\">Foldable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Literal object</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">Literal array</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">Spread in literal array</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\">Calls</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\">New</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\">Property access</td>\n<td align=\"left\">yes, if target is foldable</td>\n</tr>\n<tr>\n<td align=\"left\">Array index</td>\n<td align=\"left\">yes, if target and index are foldable</td>\n</tr>\n<tr>\n<td align=\"left\">Identity reference</td>\n<td align=\"left\">yes, if it is a reference to a local</td>\n</tr>\n<tr>\n<td align=\"left\">A template with no substitutions</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">A template with substitutions</td>\n<td align=\"left\">yes, if the substitutions are foldable</td>\n</tr>\n<tr>\n<td align=\"left\">Literal string</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">Literal number</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">Literal boolean</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">Literal null</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">Supported prefix operator</td>\n<td align=\"left\">yes, if operand is foldable</td>\n</tr>\n<tr>\n<td align=\"left\">Supported binary operator</td>\n<td align=\"left\">yes, if both left and right are foldable</td>\n</tr>\n<tr>\n<td align=\"left\">Conditional operator</td>\n<td align=\"left\">yes, if condition is foldable</td>\n</tr>\n<tr>\n<td align=\"left\">Parentheses</td>\n<td align=\"left\">yes, if the expression is foldable</td>\n</tr>\n</tbody>\n</table>\n<p>If an expression is not foldable, the collector writes it to <code>.metadata.json</code> as an <a href=\"https://en.wikipedia.org/wiki/Abstract*syntax*tree\">AST</a> for the compiler to resolve.</p>\n<h2 id=\"phase-2-code-generation\">Phase 2: code generation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a></h2>\n<p>The collector makes no attempt to understand the metadata that it collects and outputs to <code>.metadata.json</code>.\nIt represents the metadata as best it can and records errors when it detects a metadata syntax violation.\nIt's the compiler's job to interpret the <code>.metadata.json</code> in the code generation phase.</p>\n<p>The compiler understands all syntax forms that the collector supports, but it may reject <em>syntactically</em> correct metadata if the <em>semantics</em> violate compiler rules.</p>\n<h3 id=\"public-or-protected-symbols\">Public or protected symbols<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-or-protected-symbols\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler can only reference <em>exported symbols</em>.</p>\n<ul>\n<li>\n<p>Decorated component class members must be public or protected.\nYou cannot make an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property private.</p>\n</li>\n<li>\n<p>Data bound properties must also be public or protected</p>\n</li>\n</ul>\n<p><a id=\"supported-functions\"></a></p>\n<h3 id=\"supported-classes-and-functions\">Supported classes and functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#supported-classes-and-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>The collector can represent a function call or object creation with <code>new</code> as long as the syntax is valid.\nThe compiler, however, can later refuse to generate a call to a <em>particular</em> function or creation of a <em>particular</em> object.</p>\n<p>The compiler can only create instances of certain classes, supports only core decorators, and only supports calls to macros (functions or static methods) that return expressions.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Compiler action</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">New instances</td>\n<td align=\"left\">The compiler only allows metadata that create instances of the class <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> from <code>@angular/core</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Supported decorators</td>\n<td align=\"left\">The compiler only supports metadata for the <a href=\"api/core#decorators\">Angular decorators in the <code>@angular/core</code> module</a>.</td>\n</tr>\n<tr>\n<td align=\"left\">Function calls</td>\n<td align=\"left\">Factory functions must be exported, named functions. The AOT compiler does not support lambda expressions (\"arrow functions\") for factory functions.</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"function-calls\"></a></p>\n<h3 id=\"functions-and-static-method-calls\">Functions and static method calls<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#functions-and-static-method-calls\"><i class=\"material-icons\">link</i></a></h3>\n<p>The collector accepts any function or static method that contains a single <code>return</code> statement.\nThe compiler, however, only supports macros in the form of functions or static methods that return an <em>expression</em>.</p>\n<p>For example, consider the following function:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n\n</code-example>\n<p>You can call the <code>wrapInArray</code> in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.</p>\n<p>You might use  <code>wrapInArray()</code> like this:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n\n</code-example>\n<p>The compiler treats this usage as if you had written:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p>The Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> exports two macro static methods, <code>forRoot</code> and <code>forChild</code>, to help declare root and child routes.\nReview the <a href=\"https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">source code</a>\nfor these methods to see how macros can simplify configuration of complex <a href=\"guide/ngmodules\">NgModules</a>.</p>\n<p><a id=\"metadata-rewriting\"></a></p>\n<h3 id=\"metadata-rewriting\">Metadata rewriting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler treats object literals containing the fields <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>, and <code>data</code> specially, converting the expression initializing one of these fields into an exported variable that replaces the expression.\nThis process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value â€”it just needs to be able to generate a reference to the value.</p>\n<p>You might write something like:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () => TypicalServer}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p>Without rewriting, this would be invalid because lambdas are not supported and <code>TypicalServer</code> is not exported.\nTo allow this, the compiler automatically rewrites this to something like:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\nexport const Î¸0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: Î¸0}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p>This allows the compiler to generate a reference to <code>Î¸0</code> in the factory without having to know what the value of <code>Î¸0</code> contains.</p>\n<p>The compiler does the rewriting during the emit of the <code>.js</code> file.\nIt does not, however, rewrite the <code>.d.ts</code> file, so TypeScript doesn't recognize it as being an export.\nAnd it does not interfere with the ES module's exported API.</p>\n<p><a id=\"binding-expression-validation\"></a></p>\n<h2 id=\"phase-3-template-type-checking\">Phase 3: Template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p>One of the Angular compiler's most helpful features is the ability to type-check expressions within templates, and catch any errors before they cause crashes at runtime.\nIn the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.</p>\n<p>Enable this phase explicitly by adding the compiler option <code>\"fullTemplateTypeCheck\"</code> in the <code>\"angularCompilerOptions\"</code> of the project's TypeScript configuration file\n(see <a href=\"guide/angular-compiler-options\">Angular Compiler Options</a>).</p>\n<p>Template validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a <code>.ts</code>\nfile.</p>\n<p>For example, consider the following component:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p>This produces the following error:</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n\n</code-example>\n<p>The file name reported in the error message, <code>my.component.ts.MyComponent.html</code>, is a synthetic file\ngenerated by the template compiler that holds contents of the <code>MyComponent</code> class template.\nThe compiler never writes this file to disk.\nThe line and column numbers are relative to the template string in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> annotation of the class, <code>MyComponent</code> in this case.\nIf a component uses <code>templateUrl</code> instead of <code>template</code>, the errors are reported in the HTML file referenced by the <code>templateUrl</code> instead of a synthetic file.</p>\n<p>The error location is the beginning of the text node that contains the interpolation expression with the error.\nIf the error is in an attribute binding such as <code>[value]=\"person.address.street\"</code>, the error\nlocation is the location of the attribute that contains the error.</p>\n<p>The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control how detailed the type validation is.\nFor example, if the <code>strictTypeChecks</code> is specified, the error</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'\n\n</code-example>\n<p>is reported as well as the above error message.</p>\n<h3 id=\"type-narrowing\">Type narrowing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3>\n<p>The expression used in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the <code>if</code> expression does in TypeScript.\nFor example, to avoid <code>Object is possibly 'undefined'</code> error in the template above, modify it to only emit the interpolation if the value of <code>person</code> is initialized as shown below:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '<span *ngif=\"person\"> {{person.address.street}} </span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p>Using <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> allows the TypeScript compiler to infer that the <code>person</code> used in the binding expression will never be <code>undefined</code>.</p>\n<p>For more information about input type narrowing, see <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>.</p>\n<h3 id=\"non-null-type-assertion-operator\">Non-null type assertion operator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3>\n<p>Use the <a href=\"guide/template-expression-operators#non-null-assertion-operator\">non-null type assertion operator</a> to suppress the <code>Object is possibly 'undefined'</code> error when it is inconvenient to use <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or when some constraint in the component ensures that the expression is always non-null when the binding expression is interpolated.</p>\n<p>In the following example, the <code>person</code> and <code>address</code> properties are always set together, implying that <code>address</code> is always non-null if <code>person</code> is non-null.\nThere is no convenient way to describe this constraint to TypeScript and the template compiler, but the error is suppressed in the example by using <code>address!.street</code>.</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.name}} lives on {{address!.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<p>The non-null assertion operator should be used sparingly as refactoring of the component might break this constraint.</p>\n<p>In this example it is recommended to include the checking of <code>address</code> in the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> as shown below:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &#x26;&#x26; address\"> {{person.name}} lives on {{address.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">Last reviewed on Mon Feb 28 2022</div>\n</div>\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/angular-compiler-options\n - guide/aot-metadata-errors\n - guide/architecture-next-steps\n - guide/creating-libraries\n - guide/deployment\n - guide/deprecations\n - guide/file-structure\n - guide/npm-packages\n - guide/template-expression-operators\n - guide/upgrade\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core#decorators\n - api/core/Component\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/router/RouterModule\n - cli\n - cli/build\n - cli/serve\n - guide/angular-compiler-options\n - guide/aot-compiler#ahead-of-time-aot-compilation\n - guide/aot-compiler#choosing-a-compiler\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#compilation-phases\n - guide/aot-compiler#configuring-aot-compilation\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#expression-syntax-limitations\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#functions-and-static-method-calls\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#phase-1-code-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-template-type-checking\n - guide/aot-compiler#public-or-protected-symbols\n - guide/aot-compiler#supported-classes-and-functions\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#type-narrowing\n - guide/aot-metadata-errors\n - guide/build\n - guide/glossary#aot\n - guide/ngmodules\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators#non-null-assertion-operator\n - guide/typescript-configuration\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\n - https://en.wikipedia.org/wiki/Abstract*syntax*tree\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\n - https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\n - https://www.youtube.com/watch?v=anphffaCZrQ\n-->"
}