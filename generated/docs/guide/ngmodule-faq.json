{
  "id": "guide/ngmodule-faq",
  "title": "NgModule FAQ",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"ngmodule-faq\">NgModule FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faq\"><i class=\"material-icons\">link</i></a></h1>\n<p>NgModules help organize an application into cohesive blocks of functionality.</p>\n<p>This page answers the questions many developers ask about NgModule design and implementation.</p>\n<h2 id=\"what-classes-should-i-add-to-the-declarations-array\">What classes should I add to the <code>declarations</code> array?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\"><i class=\"material-icons\">link</i></a></h2>\n<p>Add <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes —components, directives, and pipes— to a <code>declarations</code> list.</p>\n<p>Declare these classes in <em>exactly one</em> module of the application.\nDeclare them in a module if they belong to that particular module.</p>\n<p><a id=\"q-declarable\"></a></p>\n<h2 id=\"what-is-a-declarable\">What is a <code>declarable</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-a-declarable\"><i class=\"material-icons\">link</i></a></h2>\n<p>Declarables are the class types —components, directives, and pipes— that you can add to a module's <code>declarations</code> list.\nThey're the only classes that you can add to <code>declarations</code>.</p>\n<h2 id=\"what-classes-should-i-not-add-to-declarations\">What classes should I <em>not</em> add to <code>declarations</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\"><i class=\"material-icons\">link</i></a></h2>\n<p>Add only <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes to an NgModule's <code>declarations</code> list.</p>\n<p>Do <em>not</em> declare the following:</p>\n<ul>\n<li>\n<p>A class that's already declared in another module, whether an application module, @NgModule, or third-party module.</p>\n</li>\n<li>\n<p>An array of directives imported from another module.\nFor example, don't declare <code>FORMS_DIRECTIVES</code> from <code>@angular/forms</code> because the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> already declares it.</p>\n</li>\n<li>\n<p>Module classes.</p>\n</li>\n<li>\n<p>Service classes.</p>\n</li>\n<li>\n<p>Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes.</p>\n</li>\n</ul>\n<h2 id=\"why-list-the-same-component-in-multiple-ngmodule-properties\">Why list the same component in multiple <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> properties?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\"><i class=\"material-icons\">link</i></a></h2>\n<p><code>AppComponent</code> is often listed in both <code>declarations</code> and <code>bootstrap</code>.\nYou might see the same component listed in <code>declarations</code> and <code>exports</code>.</p>\n<p>While that seems redundant, these properties have different functions.\nMembership in one list doesn't imply membership in another list.</p>\n<ul>\n<li><code>AppComponent</code> could be declared in this module but not bootstrapped.</li>\n<li><code>AppComponent</code> could be bootstrapped in this module but declared in a different feature module.</li>\n<li>A component could be imported from another application module (so you can't declare it) and re-exported by this module.</li>\n<li>A component could be exported for inclusion in an external component's template as well as dynamically loaded in a pop-up dialog.</li>\n</ul>\n<h2 id=\"what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\">What does \"Can't bind to 'x' since it isn't a known property of 'y'\" mean?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><i class=\"material-icons\">link</i></a></h2>\n<p>This error often means that you haven't declared the directive \"x\" or haven't imported the NgModule to which \"x\" belongs.</p>\n<div class=\"alert is-helpful\">\n<p>Perhaps you declared \"x\" in an application submodule but forgot to export it.\nThe \"x\" class isn't visible to other modules until you add it to the <code>exports</code> list.</p>\n</div>\n<h2 id=\"what-should-i-import\">What should I import?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-import\"><i class=\"material-icons\">link</i></a></h2>\n<p>Import NgModules whose public (exported) <a href=\"guide/bootstrapping#the-declarations-array\">declarable classes</a>\nyou need to reference in this module's component templates.</p>\n<p>This always means importing <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> from <code>@angular/common</code> for access to\nthe Angular directives such as <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> and <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>.\nYou can import it directly or from another NgModule that <a href=\"guide/ngmodule-faq#q-reexport\">re-exports</a> it.</p>\n<p>Import <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> from <code>@angular/forms</code>\nif your components have <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> two-way binding expressions.</p>\n<p>Import <em>shared</em> and <em>feature</em> modules when this module's components incorporate their\ncomponents, directives, and pipes.</p>\n<p>Import <a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">BrowserModule</a> only in the root <code>AppModule</code>.</p>\n<p><a id=\"q-browser-vs-common-module\"></a></p>\n<h2 id=\"should-i-import-browsermodule-or-commonmodule\">Should I import <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> or <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p>The root application module, <code>AppModule</code>, of almost every browser application should import <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> from <code>@angular/platform-browser</code>.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> provides services that are essential to launch and run a browser application.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> also re-exports <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> from <code>@angular/common</code>,\nwhich means that components in the <code>AppModule</code> also have access to\nthe Angular directives every application needs, such as <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> and <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>.</p>\n<p>Do not import <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> in any other module.\n<em>Feature modules</em> and <em>lazy-loaded modules</em> should import <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> instead.\nThey need the common directives.\nThey don't need to re-install the app-wide providers.</p>\n<p>Importing <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> also frees feature modules for use on <em>any</em> target platform, not just browsers.</p>\n<p><a id=\"q-reimport\"></a></p>\n<h2 id=\"what-if-i-import-the-same-module-twice\">What if I import the same module twice?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-i-import-the-same-module-twice\"><i class=\"material-icons\">link</i></a></h2>\n<p>That's not a problem.\nWhen three modules all import Module 'A', Angular evaluates Module 'A' once, the first time it encounters it, and doesn't do so again.</p>\n<p>That's true at whatever level <code>A</code> appears in a hierarchy of imported NgModules.\nWhen Module 'B' imports Module 'A', Module 'C' imports 'B', and Module 'D' imports <code>[C, B, A]</code>, then 'D' triggers the evaluation of 'C', which triggers the evaluation of 'B', which evaluates 'A'.\nWhen Angular gets to the 'B' and 'A' in 'D', they're already cached and ready to go.</p>\n<p>Angular doesn't like NgModules with circular references, so don't let Module 'A' import Module 'B', which imports Module 'A'.</p>\n<p><a id=\"q-reexport\"></a></p>\n<h2 id=\"what-should-i-export\">What should I export?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-export\"><i class=\"material-icons\">link</i></a></h2>\n<p>Export <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes that components in <em>other</em> NgModules are able to reference in their templates.\nThese are your <em>public</em> classes.\nIf you don't export a declarable class, it stays <em>private</em>, visible only to other components declared in this NgModule.</p>\n<p>You <em>can</em> export any declarable class —components, directives, and pipes— whether\nit's declared in this NgModule or in an imported NgModule.</p>\n<p>You <em>can</em> re-export entire imported NgModules, which effectively re-export all of their exported classes.\nAn NgModule can even export a module that it doesn't import.</p>\n<h2 id=\"what-should-i-not-export\">What should I <em>not</em> export?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-not-export\"><i class=\"material-icons\">link</i></a></h2>\n<p>Don't export the following:</p>\n<ul>\n<li>\n<p>Private components, directives, and pipes that you need only within components declared in this NgModule.\nIf you don't want another NgModule to see it, don't export it.</p>\n</li>\n<li>\n<p>Non-declarable objects such as services, functions, configurations, and entity models.</p>\n</li>\n<li>\n<p>Components that are only loaded dynamically by the router or by bootstrapping.\nSuch components can never be selected in another component's template.\nWhile there's no harm in exporting them, there's also no benefit.</p>\n</li>\n<li>\n<p>Pure service modules that don't have public (exported) declarations.\nFor example, there's no point in re-exporting <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> because it doesn't export anything.\nIts only purpose is to add http service providers to the application as a whole.</p>\n</li>\n</ul>\n<h2 id=\"can-i-re-export-classes-and-modules\">Can I re-export classes and modules?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#can-i-re-export-classes-and-modules\"><i class=\"material-icons\">link</i></a></h2>\n<p>Absolutely.</p>\n<p>NgModules are a great way to selectively aggregate classes from other NgModules and re-export them in a consolidated, convenience module.</p>\n<p>An NgModule can re-export entire NgModules, which effectively re-exports all of their exported classes.\nAngular's own <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> exports a couple of NgModules like this:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/ApplicationModule\" class=\"code-anchor\">ApplicationModule</a>]\n\n</code-example>\n<p>An NgModule can export a combination of its own declarations, selected imported classes, and imported NgModules.</p>\n<p>Don't bother re-exporting pure service modules.\nPure service modules don't export <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes that another NgModule could use.\nFor example, there's no point in re-exporting <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> because it doesn't export anything.\nIts only purpose is to add http service providers to the application as a whole.</p>\n<h2 id=\"what-is-the-forroot-method\">What is the <code>forRoot()</code> method?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-forroot-method\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>forRoot()</code> static method is a convention that makes it easy for developers to configure services and providers that are intended to be singletons.\nA good example of <code>forRoot()</code> is the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method.</p>\n<p>Applications pass a <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> array to <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> in order to configure the app-wide <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service with routes.\n<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> returns a <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>.\nYou add that result to the <code>imports</code> list of the root <code>AppModule</code>.</p>\n<p>Only call and import a <code>forRoot()</code> result in the root application module, <code>AppModule</code>.\nAvoid importing it in any other module, particularly in a lazy-loaded module.\nFor more information on <code>forRoot()</code> see <a href=\"guide/singleton-services#the-forroot-pattern\">the <code>forRoot()</code> pattern</a> section of the <a href=\"guide/singleton-services\">Singleton Services</a> guide.</p>\n<div class=\"alert is-helpful\">\n<p><strong>NOTE</strong>: <br>\nThe <code>forRoot()</code> import can be used in a module other than <code>AppModule</code>.\nImportantly, <code>forRoot()</code> should only be called once, and the module that imports the <code>forRoot()</code> needs to be available to the root <code>ModuleInjector</code>.\nFor more information, refer to the guide on <a href=\"guide/hierarchical-dependency-injection#moduleinjector\">Hierarchical injectors</a>.</p>\n</div>\n<p>For a service, instead of using <code>forRoot()</code>,  specify <code>providedIn: 'root'</code> on the service's <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator, which makes the service automatically available to the whole application and thus singleton by default.</p>\n<p><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> also offers a <code>forChild()</code> static method for configuring the routes of lazy-loaded modules.</p>\n<p><code>forRoot()</code> and <code>forChild()</code> are conventional names for methods that configure services in root and feature modules respectively.</p>\n<p>Follow this convention when you write similar modules with configurable service providers.</p>\n<h2 id=\"why-is-a-service-provided-in-a-feature-module-visible-everywhere\">Why is a service provided in a feature module visible everywhere?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><i class=\"material-icons\">link</i></a></h2>\n<p>Providers listed in the <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> of a bootstrapped module have application scope.\nAdding a service provider to <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> effectively publishes the service to the entire application.</p>\n<p>When you import an NgModule,\nAngular adds the module's service providers (the contents of its <code>providers</code> list) to the application root injector.</p>\n<p>This makes the provider visible to every class in the application that knows the provider's lookup token, or name.</p>\n<p>Extensibility through NgModule imports is a primary goal of the NgModule system.\nMerging NgModule providers into the application injector makes it easy for a module library to enrich the entire application with new services.\nBy adding the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> once, every application component can make HTTP requests.</p>\n<p>However, this might feel like an unwelcome surprise if you expect the module's services to be visible only to the components declared by that feature module.\nIf the <code>HeroModule</code> provides the <code>HeroService</code> and the root <code>AppModule</code> imports <code>HeroModule</code>, any class that knows the <code>HeroService</code> <em>type</em> can inject that service, not just the classes declared in the <code>HeroModule</code>.</p>\n<p>To limit access to a service, consider lazy loading the NgModule that provides that service.\nSee <a href=\"guide/ngmodule-faq#service-scope\">How do I restrict service scope to a module?</a> for more information.</p>\n<p><a id=\"q-lazy-loaded-module-provider-visibility\"></a></p>\n<h2 id=\"why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\">Why is a service provided in a lazy-loaded module visible only to that module?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><i class=\"material-icons\">link</i></a></h2>\n<p>Unlike providers of the modules loaded at launch, providers of lazy-loaded modules are <em>module-scoped</em>.</p>\n<p>When the Angular router lazy-loads a module, it creates a new execution context.\nThat <a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"Why Angular creates a child injector\">context has its own injector</a>, which is a direct child of the application injector.</p>\n<p>The router adds the lazy module's providers and the providers of its imported NgModules to this child injector.</p>\n<p>These providers are insulated from changes to application providers with the same lookup token.\nWhen the router creates a component within the lazy-loaded context,\nAngular prefers service instances created from these providers to the service instances of the application root injector.</p>\n<h2 id=\"what-if-two-modules-provide-the-same-service\">What if two modules provide the same service?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\"><i class=\"material-icons\">link</i></a></h2>\n<p>When two imported modules, loaded at the same time, list a provider with the same token, the second module's provider \"wins\".\nThat's because both providers are added to the same injector.</p>\n<p>When Angular looks to inject a service for that token, it creates and delivers the instance created by the second provider.</p>\n<p><em>Every</em> class that injects this service gets the instance created by the second provider.\nEven classes declared within the first module get the instance created by the second provider.</p>\n<p>If NgModule A provides a service for token 'X' and imports an NgModule B that also provides a service for token 'X', then NgModule A's service definition \"wins\".</p>\n<p>The service provided by the root <code>AppModule</code> takes precedence over services provided by imported NgModules.\nThe <code>AppModule</code> always wins.</p>\n<p><a id=\"service-scope\"></a></p>\n<h2 id=\"how-do-i-restrict-service-scope-to-a-module\">How do I restrict service scope to a module?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\"><i class=\"material-icons\">link</i></a></h2>\n<p>When a module is loaded at application launch, its <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> have <em>application-wide scope</em>; that is, they are available for injection throughout the application.</p>\n<p>Imported providers are easily replaced by providers from another imported NgModule.\nSuch replacement might be by design.\nIt could be unintentional and have adverse consequences.</p>\n<p>As a general rule, import modules with providers <em>exactly once</em>, preferably in the application's <em>root module</em>.\nThat's also usually the best place to configure, wrap, and override them.</p>\n<p>Suppose a module requires a customized <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> that adds a special header for all Http requests.\nIf another module elsewhere in the application also customizes <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> or merely imports the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>, it could override this module's <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> provider, losing the special header.\nThe server will reject http requests from this module.</p>\n<p>To avoid this problem, import the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> only in the <code>AppModule</code>, the application <em>root module</em>.</p>\n<p>If you must guard against this kind of \"provider corruption\", <em>don't rely on a launch-time module's <code>providers</code></em>.</p>\n<p>Load the module lazily if you can.\nAngular gives a <a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">lazy-loaded module</a> its own child injector.\nThe module's providers are visible only within the component tree created with this injector.</p>\n<p>If you must load the module eagerly, when the application starts, <em>provide the service in a component instead.</em></p>\n<p>Continuing with the same example, suppose the components of a module truly require a private, custom <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.</p>\n<p>Create a \"top component\" that acts as the root for all of the module's components.\nAdd the custom <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> provider to the top component's <code>providers</code> list rather than the module's <code>providers</code>.\nRecall that Angular creates a child injector for each component instance and populates the injector with the component's own providers.</p>\n<p>When a child of this component asks for the <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> service,\nAngular provides the local <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> service, not the version provided in the application root injector.\nChild components make proper HTTP requests no matter what other modules do to <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.</p>\n<p>Be sure to create module components as children of this module's top component.</p>\n<p>You can embed the child components in the top component's template.\nAlternatively, make the top component a routing host by giving it a <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>.\nDefine child routes and let the router load module components into that outlet.</p>\n<p>Though you can limit access to a service by providing it in a lazy loaded module or providing it in a component, providing services in a component can lead to multiple instances of those services.\nThus, the lazy loading is preferable.</p>\n<p><a id=\"q-root-component-or-module\"></a></p>\n<h2 id=\"should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\">Should I add application-wide providers to the root <code>AppModule</code> or the root <code>AppComponent</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><i class=\"material-icons\">link</i></a></h2>\n<p>Define application-wide providers by specifying <code>providedIn: 'root'</code> on its <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator (in the case of services) or at <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> construction (in the case where tokens are provided).\nProviders that are created this way automatically are made available to the entire application and don't need to be listed in any module.</p>\n<p>If a provider cannot be configured in this way (perhaps because it has no sensible default value), then register application-wide providers in the root <code>AppModule</code>, not in the <code>AppComponent</code>.</p>\n<p>Lazy-loaded modules and their components can inject <code>AppModule</code> services; they can't inject <code>AppComponent</code> services.</p>\n<p>Register a service in <code>AppComponent</code> providers <em>only</em> if the service must be hidden\nfrom components outside the <code>AppComponent</code> tree.\nThis is a rare use case.</p>\n<p>More generally, <a href=\"guide/ngmodule-faq#q-component-or-module\">prefer registering providers in NgModules</a> to registering in components.</p>\n<h3 id=\"discussion\">Discussion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#discussion\"><i class=\"material-icons\">link</i></a></h3>\n<p>Angular registers all startup module providers with the application root injector.\nThe services that root injector providers create have application scope, which means they are available to the entire application.</p>\n<p>Certain services, such as the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, only work when you register them in the application root injector.</p>\n<p>By contrast, Angular registers <code>AppComponent</code> providers with the <code>AppComponent</code>'s own injector.\n<code>AppComponent</code> services are available only to that component and its component tree.\nThey have component scope.</p>\n<p>The <code>AppComponent</code>'s injector is a child of the root injector, one down in the injector hierarchy.\nFor applications that don't use the router, that's almost the entire application.\nBut in routed applications, routing operates at the root level where <code>AppComponent</code> services don't exist.\nThis means that lazy-loaded modules can't reach them.</p>\n<p><a id=\"q-component-or-module\"></a></p>\n<h2 id=\"should-i-add-other-providers-to-a-module-or-a-component\">Should I add other providers to a module or a component?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<p>Providers should be configured using <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> syntax.\nIf possible, they should be provided in the application root (<code>providedIn: 'root'</code>).\nServices that are configured this way are lazily loaded if they are only used from a lazily loaded context.</p>\n<p>If it's the consumer's decision whether a provider is available application-wide or not, then register providers in modules (<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>) instead of registering in components (<code>@Component.providers</code>).</p>\n<p>Register a provider with a component when you <em>must</em> limit the scope of a service instance to that component and its component tree.\nApply the same reasoning to registering a provider with a directive.</p>\n<p>For example, an editing component that needs a private copy of a caching service should register the service with the component.\nThen each new instance of the component gets its own cached service instance.\nThe changes that editor makes in its service don't touch the instances elsewhere in the application.</p>\n<p><a href=\"guide/ngmodule-faq#q-root-component-or-module\">Always register <em>application-wide</em> services with the root <code>AppModule</code></a>, not the root <code>AppComponent</code>.</p>\n<p><a id=\"q-why-bad\"></a></p>\n<h2 id=\"why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\">Why is it bad if a shared module provides a service to a lazy-loaded module?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"the-eagerly-loaded-scenario\">The eagerly loaded scenario<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-eagerly-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n<p>When an eagerly loaded module provides a service, for example a <code>UserService</code>, that service is available application-wide.\nIf the root module provides <code>UserService</code> and imports another module that provides the same <code>UserService</code>, Angular registers one of them in the root application injector (see <a href=\"guide/ngmodule-faq#q-reimport\">What if I import the same module twice?</a>).</p>\n<p>Then, when some component injects <code>UserService</code>, Angular finds it in the application root injector, and delivers the app-wide singleton service.\nNo problem.</p>\n<h3 id=\"the-lazy-loaded-scenario\">The lazy loaded scenario<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-lazy-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n<p>Now consider a lazy loaded module that also provides a service called <code>UserService</code>.</p>\n<p>When the router lazy loads a module, it creates a child injector and registers the <code>UserService</code> provider with that child injector.\nThe child injector is <em>not</em> the root injector.</p>\n<p>When Angular creates a lazy component for that module and injects <code>UserService</code>, it finds a <code>UserService</code> provider in the lazy module's <em>child injector</em>\nand creates a <em>new</em> instance of the <code>UserService</code>.\nThis is an entirely different <code>UserService</code> instance than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</p>\n<p>This scenario causes your application to create a new instance every time, instead of using the singleton.</p>\n<!--todo: KW--What does this cause? I wasn't able to get the suggestion of this to work from\nthe current FAQ:\nTo demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the `SharedModule` so that it provides the `UserService` rather than the `CoreModule`.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new `UserService` instance each time.\nI'd like to see the error so I can include it.-->\n<p><a id=\"q-why-child-injector\"></a></p>\n<h2 id=\"why-does-lazy-loading-create-a-child-injector\">Why does lazy loading create a child injector?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular adds <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> to the application root injector, unless the NgModule is lazy-loaded.\nFor a lazy-loaded NgModule, Angular creates a <em>child injector</em> and adds the module's providers to the child injector.</p>\n<p>This means that an NgModule behaves differently depending on whether it's loaded during application start or lazy-loaded later.\nNeglecting that difference can lead to <a href=\"guide/ngmodule-faq#q-why-bad\">adverse consequences</a>.</p>\n<p>Why doesn't Angular add lazy-loaded providers to the application root injector as it does for eagerly loaded NgModules?</p>\n<p>The answer is grounded in a fundamental characteristic of the Angular dependency-injection system.\nAn injector can add providers <em>until it's first used</em>.\nOnce an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.</p>\n<p>When an application starts, Angular first configures the root injector with the providers of all eagerly loaded NgModules <em>before</em> creating its first component and injecting any of the provided services.\nOnce the application begins, the application root injector is closed to new providers.</p>\n<p>Time passes and application logic triggers lazy loading of an NgModule.\nAngular must add the lazy-loaded module's providers to an injector somewhere.\nIt can't add them to the application root injector because that injector is closed to new providers.\nSo Angular creates a new child injector for the lazy-loaded module context.</p>\n<p><a id=\"q-is-it-loaded\"></a></p>\n<h2 id=\"how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\">How can I tell if an NgModule or service was previously loaded?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\"><i class=\"material-icons\">link</i></a></h2>\n<p>Some NgModules and their services should be loaded only once by the root <code>AppModule</code>.\nImporting the module a second time by lazy loading a module could <a href=\"guide/ngmodule-faq#q-why-bad\">produce errant behavior</a> that may be difficult to detect and diagnose.</p>\n<p>To prevent this issue, write a constructor that attempts to inject the module or service from the root application injector.\nIf the injection succeeds, the class has been loaded a second time.\nYou can throw an error or take other remedial action.</p>\n<p>Certain NgModules, such as <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, implement such a guard.\nHere is a custom constructor for an NgModule called <code>GreetingModule</code>.</p>\n<code-example header=\"src/app/greeting/greeting.module.ts (Constructor)\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<h2 id=\"what-kinds-of-modules-should-i-have-and-how-should-i-use-them\">What kinds of modules should I have and how should I use them?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><i class=\"material-icons\">link</i></a></h2>\n<p>Every application is different.\nDevelopers have various levels of experience and comfort with the available choices.\nSome suggestions and guidelines appear to have wide appeal.</p>\n<h3 id=\"sharedmodule\"><code>SharedModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#sharedmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>SharedModule</code> is a conventional name for an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> with the components, directives, and pipes that you use everywhere in your application.\nThis module should consist entirely of <code>declarations</code>, most of them exported.</p>\n<p>The <code>SharedModule</code> may re-export other widget modules, such as <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>, <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>, and NgModules with the UI controls that you use most widely.</p>\n<p>The <code>SharedModule</code> should not have <code>providers</code> for reasons <a href=\"guide/ngmodule-faq#q-why-bad\">explained previously</a>.\nNor should any of its imported or re-exported modules have <code>providers</code>.</p>\n<p>Import the <code>SharedModule</code> in your <em>feature</em> modules, both those loaded when the application starts and those you lazy load later.</p>\n<h3 id=\"feature-modules\">Feature Modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#feature-modules\"><i class=\"material-icons\">link</i></a></h3>\n<p>Feature modules are modules you create around specific application business domains, user workflows, and utility collections.\nThey support your application by containing a particular feature, such as routes, services, widgets, etc.\nTo conceptualize what a feature module might be in your app, consider that if you would put the files related to a certain functionality, like a search, in one folder, that the contents of that folder would be a feature module that you might call your <code>SearchModule</code>.\nIt would contain all of the components, routing, and templates that would make up the search functionality.</p>\n<p>For more information, see <a href=\"guide/feature-modules\">Feature Modules</a> and <a href=\"guide/module-types\">Module Types</a></p>\n<h2 id=\"whats-the-difference-between-ngmodules-and-javascript-modules\">What's the difference between NgModules and JavaScript Modules?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\"><i class=\"material-icons\">link</i></a></h2>\n<p>In an Angular app, NgModules and JavaScript modules work together.</p>\n<p>In modern JavaScript, every file is a module (see the <a href=\"https://exploringjs.com/es6/ch_modules.html\">Modules</a> page of the Exploring ES6 website).\nWithin each file you write an <code>export</code> statement to make parts of the module public.</p>\n<p>An Angular NgModule is a class with the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator —JavaScript modules don't have to have the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator.\nAngular's <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> has <code>imports</code> and <code>exports</code> and they serve a similar purpose.</p>\n<p>You <em>import</em> other NgModules so you can use their exported classes in component templates.\nYou <em>export</em> this NgModule's classes so they can be imported and used by components of <em>other</em> NgModules.</p>\n<p>For more information, see <a href=\"guide/ngmodule-vs-jsmodule\">JavaScript Modules vs. NgModules</a>.</p>\n<p><a id=\"q-template-reference\"></a></p>\n<h2 id=\"how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\">How does Angular find components, directives, and pipes in a template? What is a <strong>template reference</strong>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular compiler</a> looks inside component templates for other components, directives, and pipes.\nWhen it finds one, that's a template reference.</p>\n<p>The Angular compiler finds a component or directive in a template when it can match the <em>selector</em> of that component or directive to some HTML in that template.</p>\n<p>The compiler finds a pipe if the pipe's <em>name</em> appears within the pipe syntax of the template HTML.</p>\n<p>Angular only matches selectors and pipe names for classes that are declared by this module or exported by a module that this module imports.</p>\n<p><a id=\"q-angular-compiler\"></a></p>\n<h2 id=\"what-is-the-angular-compiler\">What is the Angular compiler?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-angular-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p>The Angular compiler converts the application code you write into highly performant JavaScript code.\nThe <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata plays an important role in guiding the compilation process.</p>\n<p>The code you write isn't immediately executable.\nFor example, components have templates that contain custom elements, attribute directives, Angular binding declarations, and some peculiar syntax that clearly isn't native HTML.</p>\n<p>The Angular compiler reads the template markup, combines it with the corresponding component class code, and emits <em>component factories</em>.</p>\n<p>A component factory creates a pure, 100% JavaScript representation of the component that incorporates everything described in its <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> metadata:\nThe HTML, the binding instructions, the attached styles.</p>\n<p>Because directives and pipes appear in component templates, the Angular compiler incorporates them into compiled component code too.</p>\n<p><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata tells the Angular compiler what components to compile for this module and how to link this module with other modules.</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">Last reviewed on Mon Feb 28 2022</div>\n</div>\n\n<!-- links to this doc:\n - guide/ngmodule-api\n - guide/providers\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/http/HttpBackend\n - api/common/http/HttpClientModule\n - api/core/ApplicationModule\n - api/core/Component\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/bootstrapping#the-declarations-array\n - guide/feature-modules\n - guide/hierarchical-dependency-injection#moduleinjector\n - guide/module-types\n - guide/ngmodule-faq#can-i-re-export-classes-and-modules\n - guide/ngmodule-faq#discussion\n - guide/ngmodule-faq#feature-modules\n - guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\n - guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\n - guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\n - guide/ngmodule-faq#ngmodule-faq\n - guide/ngmodule-faq#q-angular-compiler\n - guide/ngmodule-faq#q-browser-vs-common-module\n - guide/ngmodule-faq#q-component-or-module\n - guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\n - guide/ngmodule-faq#q-reexport\n - guide/ngmodule-faq#q-reimport\n - guide/ngmodule-faq#q-root-component-or-module\n - guide/ngmodule-faq#q-why-bad\n - guide/ngmodule-faq#q-why-child-injector\n - guide/ngmodule-faq#service-scope\n - guide/ngmodule-faq#sharedmodule\n - guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\n - guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\n - guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\n - guide/ngmodule-faq#the-eagerly-loaded-scenario\n - guide/ngmodule-faq#the-lazy-loaded-scenario\n - guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\n - guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\n - guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\n - guide/ngmodule-faq#what-if-i-import-the-same-module-twice\n - guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\n - guide/ngmodule-faq#what-is-a-declarable\n - guide/ngmodule-faq#what-is-the-angular-compiler\n - guide/ngmodule-faq#what-is-the-forroot-method\n - guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\n - guide/ngmodule-faq#what-should-i-export\n - guide/ngmodule-faq#what-should-i-import\n - guide/ngmodule-faq#what-should-i-not-export\n - guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\n - guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\n - guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\n - guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\n - guide/ngmodule-vs-jsmodule\n - guide/singleton-services\n - guide/singleton-services#the-forroot-pattern\n - https://exploringjs.com/es6/ch_modules.html\n-->"
}