{
  "id": "guide/directive-composition-api",
  "title": "Directive composition API",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"directive-composition-api\">Directive composition API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1>\n<p>Angular directives offer a great way to encapsulate reusable behaviorsâ€” directives can apply\nattributes, CSS classes, and event listeners to an element.</p>\n<p>The <em>directive composition API</em> lets you apply directives to a component's host element from\n<em>within</em> the component TypeScript class.</p>\n<h2 id=\"adding-directives-to-a-component\">Adding directives to a component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<p>You apply directives to a component by adding a <code>hostDirectives</code> property to a component's\ndecorator. We call such directives <em>host directives</em>.</p>\n<p>In this example, we apply the directive <code>MenuBehavior</code> to the host element of <code>AdminMenu</code>. This\nworks similarly to applying the <code>MenuBehavior</code> to the <code>&#x3C;admin-menu></code> element in a template.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p>When the framework renders a component, Angular also creates an instance of each host directive. The\ndirectives' host bindings apply to the component's host element. By default, host directive inputs\nand outputs are not exposed as part of the component's public API. See\n<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">Including inputs and outputs</a> below for more information.</p>\n<p><strong>Angular applies host directives statically at compile time.</strong> You cannot dynamically add\ndirectives at runtime.</p>\n<p><strong>Directives used in <code>hostDirectives</code> must be <code>standalone: true</code>.</strong></p>\n<p><strong>Angular ignores the <code>selector</code> of directives applied in the <code>hostDirectives</code> property.</strong></p>\n<h2 id=\"including-inputs-and-outputs\">Including inputs and outputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n<p>When you apply <code>hostDirectives</code> to your component, the inputs and outputs from the host directives\nare not included in your component's API by default. You can explicitly include inputs and outputs\nin your component's API by expanding the entry in <code>hostDirectives</code>:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<p>By explicitly specifying the inputs and outputs, consumers of the component with <code>hostDirective</code> can\nbind them in a template:</p>\n<code-example language=\"html\">\n&#x3C;admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\">\n</code-example>\n<p>Furthermore, you can alias inputs and outputs from <code>hostDirective</code> to customize the API of your\ncomponent:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<code-example language=\"html\">\n&#x3C;admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\">\n</code-example>\n<h2 id=\"adding-directives-to-another-directive\">Adding directives to another directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can also add <code>hostDirectives</code> to other directives, in addition to components. This enables the\ntransitive aggregation of multiple behaviors.</p>\n<p>In the following example, we define two directives, <code>Menu</code> and <code>Tooltip</code>. We then compose the behavior\nof these two directives in <code>MenuWithTooltip</code>. Finally, we apply <code>MenuWithTooltip</code>\nto <code>SpecializedMenuWithTooltip</code>.</p>\n<p>When <code>SpecializedMenuWithTooltip</code> is used in a template, it creates instances of all of <code>Menu</code>\n, <code>Tooltip</code>, and <code>MenuWithTooltip</code>. Each of these directives' host bindings apply to the host\nelement of <code>SpecializedMenuWithTooltip</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Menu { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> other directives\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n</code-example>\n<h2 id=\"host-directive-semantics\">Host directive semantics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"directive-execution-order\">Directive execution order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3>\n<p>Host directives go through the same lifecycle as components and directives used directly in a\ntemplate. However, host directives always execute their constructor, lifecycle hooks, and bindings <em>before</em> the component or directive on which they are applied.</p>\n<p>The following example shows minimal use of a host directive:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p>The order of execution here is:</p>\n<ol>\n<li><code>MenuBehavior</code> instantiated</li>\n<li><code>AdminMenu</code> instantiated</li>\n<li><code>MenuBehavior</code> receives inputs (<code>ngOnInit</code>)</li>\n<li><code>AdminMenu</code> receives inputs (<code>ngOnInit</code>)</li>\n<li><code>MenuBehavior</code> applies host bindings</li>\n<li><code>AdminMenu</code> applies host bindings</li>\n</ol>\n<p>This order of operations means that components with <code>hostDirectives</code> can override any host bindings\nspecified by a host directive.</p>\n<p>This order of operations extends to nested chains of host directives, as shown in the following\nexample.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n</code-example>\n<p>In the example above, the order of execution is:</p>\n<ol>\n<li><code>Tooltip</code> instantiated</li>\n<li><code>CustomTooltip</code> instantiated</li>\n<li><code>EvenMoreCustomTooltip</code> instantiated</li>\n<li><code>Tooltip</code> receives inputs (<code>ngOnInit</code>)</li>\n<li><code>CustomTooltip</code> receives inputs (<code>ngOnInit</code>)</li>\n<li><code>EvenMoreCustomTooltip</code> receives inputs (<code>ngOnInit</code>)</li>\n<li><code>Tooltip</code> applies host bindings</li>\n<li><code>CustomTooltip</code> applies host bindings</li>\n<li><code>EvenMoreCustomTooltip</code> applies host bindings</li>\n</ol>\n<h3 id=\"dependency-injection\">Dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<p>A component or directive that specifies <code>hostDirectives</code> can inject the instances of those host\ndirectives and vice versa.</p>\n<p>When applying host directives to a component, both the component and host directives can define\nproviders.</p>\n<p>If a component or directive with <code>hostDirectives</code> and those host directives both provide the same\ninjection token, the providers defined by class with <code>hostDirectives</code> take precedence over providers\ndefined by the host directives.</p>\n<h3 id=\"performance\">Performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3>\n<p>While the directive composition API offers a powerful tool for reusing common behaviors, excessive\nuse of host directives can impact your application's memory use. If you create components or\ndirectives that use <em>many</em> host directives, you may inadvertently balloon the memory used by your\napplication.</p>\n<p>The following example shows a component that applies several host directives.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  hostDirectives: [\n    DisabledState,\n    RequiredState,\n    ValidationState,\n    ColorState,\n    RippleBehavior,\n  ],\n})\nexport class CustomCheckbox { }\n</code-example>\n<p>This example declares a custom checkbox component that includes five host directives. This\nmeans that Angular will create six objects each time a <code>CustomCheckbox</code> rendersâ€” one for the\ncomponent and one for each host directive. For a few checkboxes on a page, this won't pose any\nsignificant issues. However, if your page renders <em>hundreds</em> of checkboxes, such as in a table, then\nyou could start to see an impact of the additional object allocations. Always be sure to profile\nyour application to determine the right composition pattern for your use case.</p>\n\n  <div class=\"reviewed\">Last reviewed on Sun Dec 11 2022</div>\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Directive\n - api/forms/SelectMultipleControlValueAccessor\n - guide/directive-composition-api#adding-directives-to-a-component\n - guide/directive-composition-api#adding-directives-to-another-directive\n - guide/directive-composition-api#dependency-injection\n - guide/directive-composition-api#directive-composition-api\n - guide/directive-composition-api#directive-execution-order\n - guide/directive-composition-api#host-directive-semantics\n - guide/directive-composition-api#including-inputs-and-outputs\n - guide/directive-composition-api#performance\n-->"
}