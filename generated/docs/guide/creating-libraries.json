{
  "id": "guide/creating-libraries",
  "title": "Creating libraries",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"creating-libraries\">Creating libraries<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#creating-libraries\"><i class=\"material-icons\">link</i></a></h1>\n<p>This page provides a conceptual overview of how to create and publish new libraries to extend Angular functionality.</p>\n<p>If you find that you need to solve the same problem in more than one application (or want to share your solution with other developers), you have a candidate for a library.\nA simple example might be a button that sends users to your company website, that would be included in all applications that your company builds.</p>\n<h2 id=\"getting-started\">Getting started<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#getting-started\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use the Angular CLI to generate a new library skeleton in a new workspace with the following commands.</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng new my-workspace --no-create-application\ncd my-workspace\nng generate library my-lib\n\n</code-example>\n<div class=\"callout is-important\">\n<header>Naming your library</header>\n<p>You should be very careful when choosing the name of your library if you want to publish it later in a public package registry such as npm.\nSee <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your library</a>.</p>\n<p>Avoid using a name that is prefixed with <code>ng-</code>, such as <code>ng-library</code>.\nThe <code>ng-</code> prefix is a reserved keyword used from the Angular framework and its libraries.\nThe <code>ngx-</code> prefix is preferred as a convention used to denote that the library is suitable for use with Angular.\nIt is also an excellent indication to consumers of the registry to differentiate between libraries of different JavaScript frameworks.</p>\n</div>\n<p>The <code>ng generate</code> command creates the <code>projects/my-lib</code> folder in your workspace, which contains a component and a service inside an NgModule.</p>\n<div class=\"alert is-helpful\">\n<p>For more details on how a library project is structured, refer to the <a href=\"guide/file-structure#library-project-files\">Library project files</a> section of the <a href=\"guide/file-structure\">Project File Structure guide</a>.</p>\n<p>Use the monorepo model to use the same workspace for multiple projects.\nSee <a href=\"guide/file-structure#multiple-projects\">Setting up for a multi-project workspace</a>.</p>\n</div>\n<p>When you generate a new library, the workspace configuration file, <code>angular.json</code>, is updated with a project of type <code>library</code>.</p>\n<code-example format=\"json\">\n\n\"projects\": {\n  …\n  \"my-lib\": {\n    \"root\": \"projects/my-lib\",\n    \"sourceRoot\": \"projects/my-lib/src\",\n    \"projectType\": \"library\",\n    \"prefix\": \"lib\",\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:ng-packagr\",\n        …\n\n</code-example>\n<p>Build, test, and lint the project with CLI commands:</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib --configuration development\nng test my-lib\nng lint my-lib\n\n</code-example>\n<p>Notice that the configured builder for the project is different from the default builder for application projects.\nThis builder, among other things, ensures that the library is always built with the <a href=\"guide/aot-compiler\">AOT compiler</a>.</p>\n<p>To make library code reusable you must define a public API for it.\nThis \"user layer\" defines what is available to consumers of your library.\nA user of your library should be able to access public functionality (such as NgModules, service providers and general utility functions) through a single import path.</p>\n<p>The public API for your library is maintained in the <code>public-api.ts</code> file in your library folder.\nAnything exported from this file is made public when your library is imported into an application.\nUse an NgModule to expose services and components.</p>\n<p>Your library should supply documentation (typically a README file) for installation and maintenance.</p>\n<h2 id=\"refactoring-parts-of-an-application-into-a-library\">Refactoring parts of an application into a library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\"><i class=\"material-icons\">link</i></a></h2>\n<p>To make your solution reusable, you need to adjust it so that it does not depend on application-specific code.\nHere are some things to consider in migrating application functionality to a library.</p>\n<ul>\n<li>\n<p>Declarations such as components and pipes should be designed as stateless, meaning they don't rely on or alter external variables.\nIf you do rely on state, you need to evaluate every case and decide whether it is application state or state that the library would manage.</p>\n</li>\n<li>\n<p>Any observables that the components subscribe to internally should be cleaned up and disposed of during the lifecycle of those components</p>\n</li>\n<li>\n<p>Components should expose their interactions through inputs for providing context, and outputs for communicating events to other components</p>\n</li>\n<li>\n<p>Check all internal dependencies.</p>\n<ul>\n<li>For custom classes or interfaces used in components or service, check whether they depend on additional classes or interfaces that also need to be migrated</li>\n<li>Similarly, if your library code depends on a service, that service needs to be migrated</li>\n<li>If your library code or its templates depend on other libraries (such as Angular Material, for instance), you must configure your library with those dependencies</li>\n</ul>\n</li>\n<li>\n<p>Consider how you provide services to client applications.</p>\n<ul>\n<li>\n<p>Services should declare their own providers, rather than declaring providers in the NgModule or a component.\nDeclaring a provider makes that service <em>tree-shakable</em>.\nThis practice lets the compiler leave the service out of the bundle if it never gets injected into the application that imports the library.\nFor more about this, see <a href=\"guide/architecture-services#providing-services\">Tree-shakable providers</a>.</p>\n</li>\n<li>\n<p>If you register global service providers or share providers across multiple NgModules, use the <a href=\"guide/singleton-services\"><code>forRoot()</code> and <code>forChild()</code> design patterns</a> provided by the <a href=\"api/router/RouterModule\">RouterModule</a></p>\n</li>\n<li>\n<p>If your library provides optional services that might not be used by all client applications, support proper tree-shaking for that case by using the <a href=\"guide/lightweight-injection-tokens\">lightweight token design pattern</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"integrating-with-the-cli\"></a></p>\n<h2 id=\"integrating-with-the-cli-using-code-generation-schematics\">Integrating with the CLI using code-generation schematics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\"><i class=\"material-icons\">link</i></a></h2>\n<p>A library typically includes <em>reusable code</em> that defines components, services, and other Angular artifacts (pipes, directives) that you import into a project.\nA library is packaged into an npm package for publishing and sharing.\nThis package can also include <a href=\"guide/glossary#schematic\">schematics</a> that provide instructions for generating or transforming code directly in your project, in the same way that the CLI creates a generic new component with <code>ng generate component</code>.\nA schematic that is packaged with a library can, for example, provide the Angular CLI with the information it needs to generate a component that configures and uses a particular feature, or set of features, defined in that library.\nOne example of this is <a href=\"https://material.angular.io/guide/schematics#navigation-schematic\">Angular Material's navigation schematic</a> which configures the CDK's <a href=\"https://material.angular.io/cdk/layout/overview#breakpointobserver\">BreakpointObserver</a> and uses it with Material's <a href=\"https://material.angular.io/components/sidenav/overview\">MatSideNav</a> and <a href=\"https://material.angular.io/components/toolbar/overview\">MatToolbar</a> components.</p>\n<p>Create and include the following kinds of schematics:</p>\n<ul>\n<li>Include an installation schematic so that <code>ng add</code> can add your library to a project</li>\n<li>Include generation schematics in your library so that <code>ng generate</code> can scaffold your defined artifacts (components, services, tests) in a project</li>\n<li>Include an update schematic so that <code>ng update</code> can update your library's dependencies and provide migrations for breaking changes in new releases</li>\n</ul>\n<p>What you include in your library depends on your task.\nFor example, you could define a schematic to create a dropdown that is pre-populated with canned data to show how to add it to an application.\nIf you want a dropdown that would contain different passed-in values each time, your library could define a schematic to create it with a given configuration.\nDevelopers could then use <code>ng generate</code> to configure an instance for their own application.</p>\n<p>Suppose you want to read a configuration file and then generate a form based on that configuration.\nIf that form needs additional customization by the developer who is using your library, it might work best as a schematic.\nHowever, if the form will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\nIn general, the more complex the customization, the more useful the schematic approach.</p>\n<p>For more information, see <a href=\"guide/schematics\">Schematics Overview</a> and <a href=\"guide/schematics-for-libraries\">Schematics for Libraries</a>.</p>\n<h2 id=\"publishing-your-library\">Publishing your library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-your-library\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use the Angular CLI and the npm package manager to build and publish your library as an npm package.</p>\n<p>Angular CLI uses a tool called <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> to create packages from your compiled code that can be published to npm.\nSee <a href=\"guide/creating-libraries#ivy-libraries\">Building libraries with Ivy</a> for information on the distribution formats supported by <code>ng-packagr</code> and guidance on how\nto choose the right format for your library.</p>\n<p>You should always build libraries for distribution using the <code>production</code> configuration.\nThis ensures that generated output uses the appropriate optimizations and the correct package format for npm.</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib\ncd dist/my-lib\nnpm publish\n\n</code-example>\n<p><a id=\"lib-assets\"></a></p>\n<h2 id=\"managing-assets-in-a-library\">Managing assets in a library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#managing-assets-in-a-library\"><i class=\"material-icons\">link</i></a></h2>\n<p>In your Angular library, the distributable can include additional assets like theming files, Sass mixins, or documentation (like a changelog).\nFor more information <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\">copy assets into your library as part of the build</a> and <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\">embed assets in component styles</a>.</p>\n<div class=\"alert is-important\">\n<p>When including additional assets like Sass mixins or pre-compiled CSS.\nYou need to add these manually to the conditional <a href=\"guide/angular-package-format/#exports\">\"exports\"</a> in the <code>package.json</code> of the primary entrypoint.</p>\n<p><code>ng-packagr</code> will merge handwritten <code>\"exports\"</code> with the auto-generated ones, allowing for library authors to configure additional export subpaths, or custom conditions.</p>\n<code-example language=\"json\">\n\n\"exports\": {\n  \".\": {\n    \"sass\": \"./_index.scss\",\n  },\n  \"./theming\": {\n    \"sass\": \"./_theming.scss\"\n  },\n  \"./prebuilt-themes/indigo-pink.css\": {\n    \"style\": \"./prebuilt-themes/indigo-pink.css\"\n  }\n}\n\n</code-example>\n<p>The above is an extract from the <a href=\"https://unpkg.com/browse/@angular/material/package.json\">@angular/material</a> distributable.</p>\n</div>\n<h2 id=\"peer-dependencies\">Peer dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#peer-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular libraries should list any <code>@angular/*</code> dependencies the library depends on as peer dependencies.\nThis ensures that when modules ask for Angular, they all get the exact same module.\nIf a library lists <code>@angular/core</code> in <code>dependencies</code> instead of <code>peerDependencies</code>, it might get a different Angular module instead, which would cause your application to break.</p>\n<h2 id=\"using-your-own-library-in-applications\">Using your own library in applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#using-your-own-library-in-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p>You don't have to publish your library to the npm package manager to use it in the same workspace, but you do have to build it first.</p>\n<p>To use your own library in an application:</p>\n<ul>\n<li>\n<p>Build the library.\nYou cannot use a library before it is built.</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib\n\n</code-example>\n</li>\n<li>\n<p>In your applications, import from the library by name:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport { myExport } from 'my-lib';\n\n</code-example>\n</li>\n</ul>\n<h3 id=\"building-and-rebuilding-your-library\">Building and rebuilding your library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-and-rebuilding-your-library\"><i class=\"material-icons\">link</i></a></h3>\n<p>The build step is important if you haven't published your library as an npm package and then installed the package back into your application from npm.\nFor instance, if you clone your git repository and run <code>npm install</code>, your editor shows the <code>my-lib</code> imports as missing if you haven't yet built your library.</p>\n<div class=\"alert is-helpful\">\n<p>When you import something from a library in an Angular application, Angular looks for a mapping between the library name and a location on disk.\nWhen you install a library package, the mapping is in the <code>node_modules</code> folder.\nWhen you build your own library, it has to find the mapping in your <code>tsconfig</code> paths.</p>\n<p>Generating a library with the Angular CLI automatically adds its path to the <code>tsconfig</code> file.\nThe Angular CLI uses the <code>tsconfig</code> paths to tell the build system where to find the library.</p>\n<p>For more information, see <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">Path mapping overview</a>.</p>\n</div>\n<p>If you find that changes to your library are not reflected in your application, your application is probably using an old build of the library.</p>\n<p>You can rebuild your library whenever you make changes to it, but this extra step takes time.\n<em>Incremental builds</em> functionality improves the library-development experience.\nEvery time a file is changed a partial build is performed that emits the amended files.</p>\n<p>Incremental builds can be run as a background process in your development environment.\nTo take advantage of this feature add the <code>--watch</code> flag to the build command:</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib --watch\n\n</code-example>\n<div class=\"alert is-important\">\n<p>The CLI <code>build</code> command uses a different builder and invokes a different build tool for libraries than it does for applications.</p>\n<ul>\n<li>The build system for applications, <code>@angular-devkit/build-angular</code>, is based on <code>webpack</code>, and is included in all new Angular CLI projects</li>\n<li>The build system for libraries is based on <code>ng-packagr</code>.\nIt is only added to your dependencies when you add a library using <code>ng generate library my-lib</code>.</li>\n</ul>\n<p>The two build systems support different things, and even where they support the same things, they do those things differently.\nThis means that the TypeScript source can result in different JavaScript code in a built library than it would in a built application.</p>\n<p>For this reason, an application that depends on a library should only use TypeScript path mappings that point to the <em>built library</em>.\nTypeScript path mappings should <em>not</em> point to the library source <code>.ts</code> files.</p>\n</div>\n<p><a id=\"ivy-libraries\"></a></p>\n<h2 id=\"publishing-libraries\">Publishing libraries<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-libraries\"><i class=\"material-icons\">link</i></a></h2>\n<p>There are two distribution formats to use when publishing a library:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Distribution formats</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Partial-Ivy (recommended)</td>\n<td align=\"left\">Contains portable code that can be consumed by Ivy applications built with any version of Angular from v12 onwards.</td>\n</tr>\n<tr>\n<td align=\"left\">Full-Ivy</td>\n<td align=\"left\">Contains private Angular Ivy instructions, which are not guaranteed to work across different versions of Angular. This format requires that the library and application are built with the <em>exact</em> same version of Angular. This format is useful for environments where all library and application code is built directly from source.</td>\n</tr>\n</tbody>\n</table>\n<p>For publishing to npm use the partial-Ivy format as it is stable between patch versions of Angular.</p>\n<p>Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.</p>\n<h2 id=\"ensuring-library-version-compatibility\">Ensuring library version compatibility<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#ensuring-library-version-compatibility\"><i class=\"material-icons\">link</i></a></h2>\n<p>The Angular version used to build an application should always be the same or greater than the Angular versions used to build any of its dependent libraries.\nFor example, if you had a library using Angular version 13, the application that depends on that library should use Angular version 13 or later.\nAngular does not support using an earlier version for the application.</p>\n<p>If you intend to publish your library to npm, compile with partial-Ivy code by setting <code>\"compilationMode\": \"partial\"</code> in <code>tsconfig.prod.json</code>.\nThis partial format is stable between different versions of Angular, so is safe to publish to npm.\nCode with this format is processed during the application build using the same version of the Angular compiler, ensuring that the application and all of its libraries use a single version of Angular.</p>\n<p>Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.</p>\n<p>If you've never published a package in npm before, you must create a user account.\nRead more in <a href=\"https://docs.npmjs.com/getting-started/publishing-npm-packages\">Publishing npm Packages</a>.</p>\n<h2 id=\"consuming-partial-ivy-code-outside-the-angular-cli\">Consuming partial-Ivy code outside the Angular CLI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\"><i class=\"material-icons\">link</i></a></h2>\n<p>An application installs many Angular libraries from npm into its <code>node_modules</code> directory.\nHowever, the code in these libraries cannot be bundled directly along with the built application as it is not fully compiled.\nTo finish compilation, use the Angular linker.</p>\n<p>For applications that don't use the Angular CLI, the linker is available as a <a href=\"https://babeljs.io\">Babel</a> plugin.\nThe plugin is to be imported from <code>@angular/compiler-cli/linker/babel</code>.</p>\n<p>The Angular linker Babel plugin supports build caching, meaning that libraries only need to be processed by the linker a single time, regardless of other npm operations.</p>\n<p>Example of integrating the plugin into a custom <a href=\"https://webpack.js.org\">Webpack</a> build by registering the linker as a <a href=\"https://babeljs.io\">Babel</a> plugin using <a href=\"https://webpack.js.org/loaders/babel-loader/#options\">babel-loader</a>.</p>\n<code-example header=\"webpack.config.mjs\" path=\"angular-linker-plugin/webpack.config.mjs\" region=\"webpack-config\">\nimport linkerPlugin from '@angular/compiler-cli/linker/babel';\n\nexport default {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: [linkerPlugin],\n            compact: false,\n            cacheDirectory: true,\n          }\n        }\n      }\n    ]\n  }\n  // ...\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>The Angular CLI integrates the linker plugin automatically, so if consumers of your library are using the CLI, they can install Ivy-native libraries from npm without any additional configuration.</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">Last reviewed on Mon Feb 28 2022</div>\n</div>\n\n<!-- links to this doc:\n - guide/angular-package-format\n - guide/cli-builder\n - guide/file-structure\n - guide/glossary\n - guide/libraries\n - guide/npm-packages\n-->\n<!-- links from this doc:\n - api/router/RouterModule\n - guide/angular-package-format/#exports\n - guide/aot-compiler\n - guide/architecture-services#providing-services\n - guide/creating-libraries#building-and-rebuilding-your-library\n - guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\n - guide/creating-libraries#creating-libraries\n - guide/creating-libraries#ensuring-library-version-compatibility\n - guide/creating-libraries#getting-started\n - guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\n - guide/creating-libraries#ivy-libraries\n - guide/creating-libraries#managing-assets-in-a-library\n - guide/creating-libraries#peer-dependencies\n - guide/creating-libraries#publishing-libraries\n - guide/creating-libraries#publishing-your-library\n - guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\n - guide/creating-libraries#using-your-own-library-in-applications\n - guide/file-structure\n - guide/file-structure#library-project-files\n - guide/file-structure#multiple-projects\n - guide/glossary#schematic\n - guide/lightweight-injection-tokens\n - guide/schematics\n - guide/schematics-for-libraries\n - guide/singleton-services\n - https://babeljs.io\n - https://docs.npmjs.com/getting-started/publishing-npm-packages\n - https://github.com/ng-packagr/ng-packagr/blob/master/README.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\n - https://material.angular.io/cdk/layout/overview#breakpointobserver\n - https://material.angular.io/components/sidenav/overview\n - https://material.angular.io/components/toolbar/overview\n - https://material.angular.io/guide/schematics#navigation-schematic\n - https://unpkg.com/browse/@angular/material/package.json\n - https://webpack.js.org\n - https://webpack.js.org/loaders/babel-loader/#options\n - https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\n-->"
}