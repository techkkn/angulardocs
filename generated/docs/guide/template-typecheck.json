{
  "id": "guide/template-typecheck",
  "title": "Template type checking",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"template-type-checking\">Template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#template-type-checking\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"overview-of-template-type-checking\">Overview of template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#overview-of-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p>Just as TypeScript catches type errors in your code, Angular checks the expressions and bindings within the templates of your application and can report any type errors it finds.\nAngular currently has three modes of doing this, depending on the value of the <code>fullTemplateTypeCheck</code> and <code>strictTemplates</code> flags in the <a href=\"guide/typescript-configuration\">TypeScript configuration file</a>.</p>\n<h3 id=\"basic-mode\">Basic mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#basic-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p>In the most basic type-checking mode, with the <code>fullTemplateTypeCheck</code> flag set to <code>false</code>, Angular validates only top-level expressions in a template.</p>\n<p>If you write <code>&#x3C;map [city]=\"user.address.city\"></code>, the compiler verifies the following:</p>\n<ul>\n<li><code>user</code> is a property on the component class</li>\n<li><code>user</code> is an object with an address property</li>\n<li><code>user.address</code> is an object with a city property</li>\n</ul>\n<p>The compiler does not verify that the value of <code>user.address.city</code> is assignable to the city input of the <code>&#x3C;map></code> component.</p>\n<p>The compiler also has some major limitations in this mode:</p>\n<ul>\n<li>Importantly, it doesn't check embedded views, such as <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>, <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>, other <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&#x3C;ng-template></a></code> embedded view.</li>\n<li>It doesn't figure out the types of <code>#refs</code>, the results of pipes, or the type of <code>$event</code> in event bindings.</li>\n</ul>\n<p>In many cases, these things end up as type <code>any</code>, which can cause subsequent parts of the expression to go unchecked.</p>\n<h3 id=\"full-mode\">Full mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#full-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p>If the <code>fullTemplateTypeCheck</code> flag is set to <code>true</code>, Angular is more aggressive in its type-checking within templates.\nIn particular:</p>\n<ul>\n<li>Embedded views (such as those within an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>) are checked</li>\n<li>Pipes have the correct return type</li>\n<li>Local references to directives and pipes have the correct type (except for any generic parameters, which will be <code>any</code>)</li>\n</ul>\n<p>The following still have type <code>any</code>.</p>\n<ul>\n<li>Local references to DOM elements</li>\n<li>The <code>$event</code> object</li>\n<li>Safe navigation expressions</li>\n</ul>\n<div class=\"alert is-important\">\n<p>The <code>fullTemplateTypeCheck</code> flag has been deprecated in Angular 13.\nThe <code>strictTemplates</code> family of compiler options should be used instead.</p>\n</div>\n<p><a id=\"strict-mode\"></a></p>\n<h3 id=\"strict-mode\">Strict mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p>Angular maintains the behavior of the <code>fullTemplateTypeCheck</code> flag, and introduces a third \"strict mode\".\nStrict mode is a superset of full mode, and is accessed by setting the <code>strictTemplates</code> flag to true.\nThis flag supersedes the <code>fullTemplateTypeCheck</code> flag.\nIn strict mode, Angular uses checks that go beyond the version 8 type-checker.</p>\n<div class=\"alert is-helpful\">\n<p><strong>NOTE</strong>: <br>\nStrict mode is only available if using Ivy.</p>\n</div>\n<p>In addition to the full mode behavior, Angular does the following:</p>\n<ul>\n<li>Verifies that component/directive bindings are assignable to their <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>s</li>\n<li>Obeys TypeScript's <code>strictNullChecks</code> flag when validating the preceding mode</li>\n<li>Infers the correct type of components/directives, including generics</li>\n<li>Infers template context types where configured (for example, allowing correct type-checking of <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>)</li>\n<li>Infers the correct type of <code>$event</code> in component/directive, DOM, and animation event bindings</li>\n<li>Infers the correct type of local references to DOM elements, based on the tag name (for example, the type that <code>document.createElement</code> would return for that tag)</li>\n</ul>\n<h2 id=\"checking-of-ngfor\">Checking of <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#checking-of-ngfor\"><i class=\"material-icons\">link</i></a></h2>\n<p>The three modes of type-checking treat embedded views differently.\nConsider the following example.</p>\n<code-example language=\"typescript\" header=\"User interface\">\n\ninterface User {\n  name: string;\n  address: {\n    city: string;\n    state: string;\n  }\n}\n\n</code-example>\n<code-example format=\"html\" language=\"html\">\n\n&#x3C;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let user of users\">\n  &#x3C;h2>{{config.title}}&#x3C;/h2>\n  &#x3C;span>City: {{user.address.city}}&#x3C;/span>\n&#x3C;/div>\n\n</code-example>\n<p>The <code>&#x3C;h2></code> and the <code>&#x3C;span></code> are in the <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> embedded view.\nIn basic mode, Angular doesn't check either of them.\nHowever, in full mode, Angular checks that <code>config</code> and <code>user</code> exist and assumes a type of <code>any</code>.\nIn strict mode, Angular knows that the <code>user</code> in the <code>&#x3C;span></code> has a type of <code>User</code>, and that <code>address</code> is an object with a <code>city</code> property of type <code>string</code>.</p>\n<p><a id=\"troubleshooting-template-errors\"></a></p>\n<h2 id=\"troubleshooting-template-errors\">Troubleshooting template errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#troubleshooting-template-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p>With strict mode, you might encounter template errors that didn't arise in either of the previous modes.\nThese errors often represent genuine type mismatches in the templates that were not caught by the previous tooling.\nIf this is the case, the error message should make it clear where in the template the problem occurs.</p>\n<p>There can also be false positives when the typings of an Angular library are either incomplete or incorrect, or when the typings don't quite line up with expectations as in the following cases.</p>\n<ul>\n<li>\n<p>When a library's typings are wrong or incomplete (for example, missing <code>null | undefined</code> if the library was not written with <code>strictNullChecks</code> in mind)</p>\n</li>\n<li>\n<p>When a library's input types are too narrow and the library hasn't added appropriate metadata for Angular to figure this out.\nThis usually occurs with disabled or other common Boolean inputs used as attributes, for example, <code>&#x3C;input disabled></code>.</p>\n</li>\n<li>\n<p>When using <code>$event.target</code> for DOM events (because of the possibility of event bubbling, <code>$event.target</code> in the DOM typings doesn't have the type you might expect)</p>\n</li>\n</ul>\n<p>In case of a false positive like these, there are a few options:</p>\n<ul>\n<li>Use the <a href=\"guide/template-expression-operators#any-type-cast-function\"><code>$any()</code> type-cast function</a> in certain contexts to opt out of type-checking for a part of the expression</li>\n<li>Disable strict checks entirely by setting <code>strictTemplates: false</code> in the application's TypeScript configuration file, <code>tsconfig.json</code></li>\n<li>Disable certain type-checking operations individually, while maintaining strictness in other aspects, by setting a <em>strictness flag</em> to <code>false</code></li>\n<li>If you want to use <code>strictTemplates</code> and <code>strictNullChecks</code> together, opt out of strict null type checking specifically for input bindings using <code>strictNullInputTypes</code></li>\n</ul>\n<p>Unless otherwise commented, each following option is set to the value for <code>strictTemplates</code> (<code>true</code> when <code>strictTemplates</code> is <code>true</code> and conversely, the other way around).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Strictness flag</th>\n<th align=\"left\">Effect</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>strictInputTypes</code></td>\n<td align=\"left\">Whether the assignability of a binding expression to the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> field is checked. Also affects the inference of directive generic types.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictInputAccessModifiers</code></td>\n<td align=\"left\">Whether access modifiers such as <code>private</code>/<code>protected</code>/<code>readonly</code> are honored when assigning a binding expression to an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>. If disabled, the access modifiers of the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> are ignored; only the type is checked. This option is <code>false</code> by default, even with <code>strictTemplates</code> set to <code>true</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictNullInputTypes</code></td>\n<td align=\"left\">Whether <code>strictNullChecks</code> is honored when checking <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> bindings (per <code>strictInputTypes</code>). Turning this off can be useful when using a library that was not built with <code>strictNullChecks</code> in mind.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictAttributeTypes</code></td>\n<td align=\"left\">Whether to check <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> bindings that are made using text attributes. For example, <code-example format=\"html\" hidecopy=\"\" language=\"html\"> &#x3C;input matInput disabled=\"true\"> </code-example> (setting the <code>disabled</code> property to the string <code>'true'</code>) vs <code-example format=\"html\" hidecopy=\"\" language=\"html\"> &#x3C;input matInput [disabled]=\"true\"> </code-example> (setting the <code>disabled</code> property to the boolean <code>true</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictSafeNavigationTypes</code></td>\n<td align=\"left\">Whether the return type of safe navigation operations (for example, <code>user?.name</code> will be correctly inferred based on the type of <code>user</code>). If disabled, <code>user?.name</code> will be of type <code>any</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictDomLocalRefTypes</code></td>\n<td align=\"left\">Whether local references to DOM elements will have the correct type. If disabled <code>ref</code> will be of type <code>any</code> for <code>&#x3C;input #ref></code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictOutputEventTypes</code></td>\n<td align=\"left\">Whether <code>$event</code> will have the correct type for event bindings to component/directive an <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>, or to animation events. If disabled, it will be <code>any</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictDomEventTypes</code></td>\n<td align=\"left\">Whether <code>$event</code> will have the correct type for event bindings to DOM events. If disabled, it will be <code>any</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictContextGenerics</code></td>\n<td align=\"left\">Whether the type parameters of generic components will be inferred correctly (including any generic bounds). If disabled, any type parameters will be <code>any</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictLiteralTypes</code></td>\n<td align=\"left\">Whether object and array literals declared in the template will have their type inferred. If disabled, the type of such literals will be <code>any</code>. This flag is <code>true</code> when <em>either</em> <code>fullTemplateTypeCheck</code> or <code>strictTemplates</code> is set to <code>true</code>.</td>\n</tr>\n</tbody>\n</table>\n<p>If you still have issues after troubleshooting with these flags, fall back to full mode by disabling <code>strictTemplates</code>.</p>\n<p>If that doesn't work, an option of last resort is to turn off full mode entirely with <code>fullTemplateTypeCheck: false</code>.</p>\n<p>A type-checking error that you cannot resolve with any of the recommended methods can be the result of a bug in the template type-checker itself.\nIf you get errors that require falling back to basic mode, it is likely to be such a bug.\nIf this happens, <a href=\"https://github.com/angular/angular/issues\">file an issue</a> so the team can address it.</p>\n<h2 id=\"inputs-and-type-checking\">Inputs and type-checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#inputs-and-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p>The template type checker checks whether a binding expression's type is compatible with that of the corresponding directive input.\nAs an example, consider the following component:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport interface User {\n  name: string;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'user-detail',\n  template: '{{ user.name }}',\n})\nexport class UserDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() user: User;\n}\n\n</code-example>\n<p>The <code>AppComponent</code> template uses this component as follows:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;user-detail [user]=\"selectedUser\">&#x3C;/user-detail>',\n})\nexport class AppComponent {\n  selectedUser: User | null = null;\n}\n\n</code-example>\n<p>Here, during type checking of the template for <code>AppComponent</code>, the <code>[user]=\"selectedUser\"</code> binding corresponds with the <code>UserDetailComponent.user</code> input.\nTherefore, Angular assigns the <code>selectedUser</code> property to <code>UserDetailComponent.user</code>, which would result in an error if their types were incompatible.\nTypeScript checks the assignment according to its type system, obeying flags such as <code>strictNullChecks</code> as they are configured in the application.</p>\n<p>Avoid run-time type errors by providing more specific in-template type requirements to the template type checker.\nMake the input type requirements for your own directives as specific as possible by providing template-guard functions in the directive definition.\nSee <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a> in this guide.</p>\n<h3 id=\"strict-null-checks\">Strict null checks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-null-checks\"><i class=\"material-icons\">link</i></a></h3>\n<p>When you enable <code>strictTemplates</code> and the TypeScript flag <code>strictNullChecks</code>, typecheck errors might occur for certain situations that might not easily be avoided.\nFor example:</p>\n<ul>\n<li>\n<p>A nullable value that is bound to a directive from a library which did not have <code>strictNullChecks</code> enabled.</p>\n<p>For a library compiled without <code>strictNullChecks</code>, its declaration files will not indicate whether a field can be <code>null</code> or not.\nFor situations where the library handles <code>null</code> correctly, this is problematic, as the compiler will check a nullable value against the declaration files which omit the <code>null</code> type.\nAs such, the compiler produces a type-check error because it adheres to <code>strictNullChecks</code>.</p>\n</li>\n<li>\n<p>Using the <code>async</code> pipe with an Observable which you know will emit synchronously.</p>\n<p>The <code>async</code> pipe currently assumes that the Observable it subscribes to can be asynchronous, which means that it's possible that there is no value available yet.\nIn that case, it still has to return something â€”which is <code>null</code>.\nIn other words, the return type of the <code>async</code> pipe includes <code>null</code>, which might result in errors in situations where the Observable is known to emit a non-nullable value synchronously.</p>\n</li>\n</ul>\n<p>There are two potential workarounds to the preceding issues:</p>\n<ul>\n<li>\n<p>In the template, include the non-null assertion operator <code>!</code> at the end of a nullable expression, such as</p>\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&#x3C;user-detail [user]=\"user!\">&#x3C;/user-detail>\n\n</code-example>\n<p>In this example, the compiler disregards type incompatibilities in nullability, just as in TypeScript code.\nIn the case of the <code>async</code> pipe, notice that the expression needs to be wrapped in parentheses, as in</p>\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&#x3C;user-detail [user]=\"(user$ | <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a>)!\">&#x3C;/user-detail>\n\n</code-example>\n</li>\n<li>\n<p>Disable strict null checks in Angular templates completely.</p>\n<p>When <code>strictTemplates</code> is enabled, it is still possible to disable certain aspects of type checking.\nSetting the option <code>strictNullInputTypes</code> to <code>false</code> disables strict null checks within Angular templates.\nThis flag applies for all components that are part of the application.</p>\n</li>\n</ul>\n<h3 id=\"advice-for-library-authors\">Advice for library authors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#advice-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n<p>As a library author, you can take several measures to provide an optimal experience for your users.\nFirst, enabling <code>strictNullChecks</code> and including <code>null</code> in an input's type, as appropriate, communicates to your consumers whether they can provide a nullable value or not.\nAdditionally, it is possible to provide type hints that are specific to the template type checker.\nSee <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>, and <a href=\"guide/template-typecheck#input-setter-coercion\">Input setter coercion</a>.</p>\n<p><a id=\"input-setter-coercion\"></a></p>\n<h2 id=\"input-setter-coercion\">Input setter coercion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#input-setter-coercion\"><i class=\"material-icons\">link</i></a></h2>\n<p>Occasionally it is desirable for the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> of a directive or component to alter the value bound to it, typically using a getter/setter pair for the input.\nAs an example, consider this custom button component:</p>\n<p>Consider the following directive:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'submit-button',\n  template: `\n    &#x3C;div class=\"wrapper\">\n      &#x3C;button [disabled]=\"disabled\">Submit&#x3C;/button>\n    &#x3C;/div>\n  `,\n})\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n}\n\n</code-example>\n<p>Here, the <code>disabled</code> input of the component is being passed on to the <code>&#x3C;button></code> in the template.\nAll of this works as expected, as long as a <code>boolean</code> value is bound to the input.\nBut, suppose a consumer uses this input in the template as an attribute:</p>\n<code-example format=\"html\" language=\"html\">\n\n&#x3C;submit-button disabled>&#x3C;/submit-button>\n\n</code-example>\n<p>This has the same effect as the binding:</p>\n<code-example format=\"html\" language=\"html\">\n\n&#x3C;submit-button [disabled]=\"''\">&#x3C;/submit-button>\n\n</code-example>\n<p>At runtime, the input will be set to the empty string, which is not a <code>boolean</code> value.\nAngular component libraries that deal with this problem often \"coerce\" the value into the right type in the setter:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nset disabled(value: boolean) {\n  this._disabled = (value === '') || value;\n}\n\n</code-example>\n<p>It would be ideal to change the type of <code>value</code> here, from <code>boolean</code> to <code>boolean|''</code>, to match the set of values which are actually accepted by the setter.\nTypeScript prior to version 4.3 requires that both the getter and setter have the same type, so if the getter should return a <code>boolean</code> then the setter is stuck with the narrower type.</p>\n<p>If the consumer has Angular's strictest type checking for templates enabled, this creates a problem: the empty string (<code>''</code>) is not actually assignable to the <code>disabled</code> field, which creates a type error when the attribute form is used.</p>\n<p>As a workaround for this problem, Angular supports checking a wider, more permissive type for <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> than is declared for the input field itself.\nEnable this by adding a static property with the <code>ngAcceptInputType_</code> prefix to the component class:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set disabled(value: boolean) {\n    this._disabled = (value === '') || value;\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngAcceptInputType_disabled: boolean|'';\n}\n\n</code-example>\n<div class=\"alert is-important\">\n<p>Since TypeScript 4.3, the setter could have been declared to accept <code>boolean|''</code> as type, making the input setter coercion field obsolete.\nAs such, input setters coercion fields have been deprecated.</p>\n</div>\n<p>This field does not need to have a value.\nIts existence communicates to the Angular type checker that the <code>disabled</code> input should be considered as accepting bindings that match the type <code>boolean|''</code>.\nThe suffix should be the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>field</em> name.</p>\n<p>Care should be taken that if an <code>ngAcceptInputType_</code> override is present for a given input, then the setter should be able to handle any values of the overridden type.</p>\n<h2 id=\"disabling-type-checking-using-any\">Disabling type checking using <code>$any()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h2>\n<p>Disable checking of a binding expression by surrounding the expression in a call to the <a href=\"guide/template-expression-operators\"><code>$any()</code> cast pseudo-function</a>.\nThe compiler treats it as a cast to the <code>any</code> type just like in TypeScript when a <code>&#x3C;any></code> or <code>as any</code> cast is used.</p>\n<p>In the following example, casting <code>person</code> to the <code>any</code> type suppresses the error <code>Property address does not exist</code>.</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).address.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">Last reviewed on Mon Feb 28 2022</div>\n</div>\n\n<!-- links to this doc:\n - extended-diagnostics\n - extended-diagnostics/NG8101\n - extended-diagnostics/NG8102\n - guide/angular-compiler-options\n - guide/deprecations\n - guide/strict-mode\n - guide/structural-directives\n - guide/typescript-configuration\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Input\n - api/core/Output\n - api/core/ng-template\n - api/platform-browser/animations/async\n - api/upgrade/static\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators\n - guide/template-expression-operators#any-type-cast-function\n - guide/template-typecheck#advice-for-library-authors\n - guide/template-typecheck#basic-mode\n - guide/template-typecheck#checking-of-ngfor\n - guide/template-typecheck#disabling-type-checking-using-any\n - guide/template-typecheck#full-mode\n - guide/template-typecheck#input-setter-coercion\n - guide/template-typecheck#inputs-and-type-checking\n - guide/template-typecheck#overview-of-template-type-checking\n - guide/template-typecheck#strict-mode\n - guide/template-typecheck#strict-null-checks\n - guide/template-typecheck#template-type-checking\n - guide/template-typecheck#troubleshooting-template-errors\n - guide/typescript-configuration\n - https://github.com/angular/angular/issues\n-->"
}