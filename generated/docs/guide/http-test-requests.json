{
  "id": "guide/http-test-requests",
  "title": "HTTP client - Test requests",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"http-client---test-requests\">HTTP client - Test requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1>\n<p>As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server.\nThe <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> library makes it straightforward to set up such mocking.</p>\n<h2 id=\"http-testing-library\">HTTP testing library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular's HTTP testing library is designed for a pattern of testing in which the app executes code and makes requests first.\nThe test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request.</p>\n<p>At the end, tests can verify that the app made no unexpected requests.</p>\n<div class=\"alert is-helpful\">\n<p>You can run <live-example stackblitz=\"specs\" name=\"http\">these sample tests</live-example> in a live coding environment.</p>\n<p>The tests described in this guide are in <code>src/testing/http-client.spec.ts</code>.\nThere are also tests of an application data service that call <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in <code>src/app/heroes/heroes.service.spec.ts</code>.</p>\n</div>\n<h2 id=\"setup-for-testing\">Setup for testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2>\n<p>To begin testing calls to <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, import the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> and the mocking controller, <code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>, along with the other symbols your tests require.</p>\n<code-example header=\"app/testing/http-client.spec.ts (imports)\" path=\"http/src/testing/http-client.spec.ts\" region=\"imports\">\n// Http testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n\n</code-example>\n<p>Then add the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> to the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> and continue with the setup of the <em>service-under-test</em>.</p>\n<code-example header=\"app/testing/http-client.spec.ts(setup)\" path=\"http/src/testing/http-client.spec.ts\" region=\"setup\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () => {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the <a href=\"api/common/http\" class=\"code-anchor\">http</a> service and test controller for each test\n    httpClient = TestBed.inject(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p>Now requests made in the course of your tests hit the testing backend instead of the normal backend.</p>\n<p>This setup also calls <code>TestBed.inject()</code> to inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service and the mocking controller so they can be referenced during the tests.</p>\n<h2 id=\"expect-and-answer-requests\">Expect and answer requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2>\n<p>Now you can write a test that expects a GET Request to occur and provides a mock response.</p>\n<code-example header=\"app/testing/http-client.spec.ts (HttpClient.get)\" path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\">\nit('can test HttpClient.get', () => {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&#x3C;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>>(testUrl)\n    .subscribe(data =>\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p>The last step, verifying that no requests remain outstanding, is common enough for you to move it into an <code>afterEach()</code> step:</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\">\nafterEach(() => {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h3 id=\"custom-request-expectations\">Custom request expectations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3>\n<p>If matching by URL isn't sufficient, it's possible to implement your own matching function.\nFor example, you could look for an outgoing request that has an authorization header:</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  request => request.headers.has('Authorization')\n);\n\n</code-example>\n<p>As with the previous <code>expectOne()</code>, the test fails if 0 or 2+ requests satisfy this predicate.</p>\n<h3 id=\"handle-more-than-one-request\">Handle more than one request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3>\n<p>If you need to respond to duplicate requests in your test, use the <code>match()</code> API instead of <code>expectOne()</code>.\nIt takes the same arguments but returns an array of matching requests.\nOnce returned, these requests are removed from future matching and you are responsible for flushing and verifying them.</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h2 id=\"test-for-errors\">Test for errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p>You should test the app's defenses against HTTP requests that fail.</p>\n<p>Call <code>request.flush()</code> with an error message, as seen in the following example.</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\">\nit('can test for 404 error', () => {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&#x3C;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]>(testUrl).subscribe({\n    next: () => fail('should have failed with the 404 error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) => {\n      expect(error.status).withContext('status').toEqual(404);\n      expect(error.error).withContext('message').toEqual(emsg);\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n<p>Alternatively, call <code>request.error()</code> with a <code>ProgressEvent</code>.</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"network-error\">\nit('can test for network error', done => {\n  // Create mock ProgressEvent with type `error`, raised when something goes wrong\n  // at network level. e.g. Connection timeout, DNS error, offline, etc.\n  const mockError = new ProgressEvent('error');\n\n  httpClient.get&#x3C;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]>(testUrl).subscribe({\n    next: () => fail('should have failed with the network error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) => {\n      expect(error.error).toBe(mockError);\n      done();\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.error(mockError);\n});\n\n</code-example>\n\n  <div class=\"reviewed\">Last reviewed on Mon Nov 14 2022</div>\n</div>\n\n<!-- links to this doc:\n - guide/testing-services\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/testing/TestBed\n - api/forms/SelectMultipleControlValueAccessor\n - api/router/Data\n - guide/http-test-requests#custom-request-expectations\n - guide/http-test-requests#expect-and-answer-requests\n - guide/http-test-requests#handle-more-than-one-request\n - guide/http-test-requests#http-client---test-requests\n - guide/http-test-requests#http-testing-library\n - guide/http-test-requests#setup-for-testing\n - guide/http-test-requests#test-for-errors\n-->"
}