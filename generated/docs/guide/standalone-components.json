{
  "id": "guide/standalone-components",
  "title": "Getting started with standalone components",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"getting-started-with-standalone-components\">Getting started with standalone components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1>\n<p><strong>Standalone components</strong> provide a simplified way to build Angular applications. Standalone components, directives, and pipes aim to streamline the authoring experience by reducing the need for <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. Existing applications can optionally and incrementally adopt the new standalone style without any breaking changes.</p>\n<h2 id=\"creating-standalone-components\">Creating standalone components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"video-container\">\n<iframe src=\"https://www.youtube.com/embed/x5PZwb4XurU\" title=\"Getting started with standalone components\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<h3 id=\"the-standalone-flag-and-component-imports\">The <code>standalone</code> flag and component <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3>\n<p>Components, directives, and pipes can now be marked as <code>standalone: true</code>. Angular classes marked as standalone do not need to be declared in an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> (the Angular compiler will report an error if you try).</p>\n<p>Standalone components specify their dependencies directly instead of getting them through <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. For example, if <code>PhotoGalleryComponent</code> is a standalone component, it can directly import another standalone component <code>ImageGridComponent</code>:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  imports: [ImageGridComponent],\n  template: `\n    ... &#x3C;image-grid [images]=\"imageList\">&#x3C;/image-grid>\n  `,\n})\nexport class PhotoGalleryComponent {\n  // component logic\n}\n</code-example>\n<p><code>imports</code> can also be used to reference standalone directives and pipes. In this way, standalone components can be written without the need to create an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> to manage template dependencies.</p>\n<h3 id=\"using-existing-ngmodules-in-a-standalone-component\">Using existing NgModules in a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n<p>When writing a standalone component, you may want to use other components, directives, or pipes in the component's template. Some of those dependencies might not be marked as standalone, but instead declared and exported by an existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>. In this case, you can import the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> directly into the standalone component:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  // an existing module is imported directly into a standalone component\n  imports: [MatButtonModule],\n  template: `\n    ...\n    &#x3C;button mat-button>Next Page&#x3C;/button>\n  `,\n})\nexport class PhotoGalleryComponent {\n  // logic\n}\n</code-example>\n<p>You can use standalone components with existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>-based libraries or dependencies in your template. Standalone components can take full advantage of the existing ecosystem of Angular libraries.</p>\n<h2 id=\"using-standalone-components-in-ngmodule-based-applications\">Using standalone components in NgModule-based applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p>Standalone components can also be imported into existing NgModules-based contexts. This allows existing applications (which are using NgModules today) to incrementally adopt the new, standalone style of component.</p>\n<p>You can import a standalone component (or directive, or pipe) just like you would an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> - using <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [AlbumComponent],\n  exports: [AlbumComponent], \n  imports: [PhotoGalleryComponent],\n})\nexport class AlbumModule {}\n</code-example>\n<h2 id=\"bootstrapping-an-application-using-a-standalone-component\">Bootstrapping an application using a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2>\n<p>An Angular application can be bootstrapped without any <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> by using a standalone component as the application's root component. This is done using the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API:</p>\n<code-example language=\"ts\">\n// in the main.ts file\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>} from '@angular/platform-browser';\nimport {PhotoAppComponent} from './app/photo.app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent);\n</code-example>\n<h3 id=\"configuring-dependency-injection\">Configuring dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<p>When bootstrapping an application, often you want to configure Angular’s dependency injection and provide configuration values or services for use throughout the application. You can pass these as providers to <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>:</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    // ...\n  ]\n});\n</code-example>\n<p>The standalone bootstrap operation is based on explicitly configuring a list of <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code>s for dependency injection. In Angular, <code>provide</code>-prefixed functions can be used to configure different systems without needing to import NgModules. For example, <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> is used in place of <code>RouterModule.forRoot</code> to configure the router:</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([/* app routes */]),\n    // ...\n  ]\n});\n</code-example>\n<p>Many third party libraries have also been updated to support this <code>provide</code>-function configuration pattern. If a library only offers an NgModule API for its DI configuration, you can use the <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> utility to still use it with <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> and other standalone contexts:</p>\n<code-example language=\"ts\">\nimport {LibraryModule} from 'ngmodule-based-library';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(\n      LibraryModule.forRoot()\n    ),\n  ]\n});\n</code-example>\n<h2 id=\"routing-and-lazy-loading\">Routing and lazy-loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n<p>The router APIs were updated and simplified to take advantage of the standalone components: an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> is no longer required in many common, lazy-loading scenarios.</p>\n<h3 id=\"lazy-loading-a-standalone-component\">Lazy loading a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n<p>Any route can lazily load its routed, standalone component by using <code>loadComponent</code>:</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadComponent: () => import('./admin/panel.component').then(mod => mod.AdminPanelComponent)},\n  // ...\n];\n</code-example>\n<p>This works as long as the loaded component is standalone.</p>\n<h3 id=\"lazy-loading-many-routes-at-once\">Lazy loading many routes at once<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>loadChildren</code> operation now supports loading a new set of child <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>s without needing to write a lazy loaded <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> that imports <code>RouterModule.forChild</code> to declare the routes. This works when every route loaded this way is using a standalone component.</p>\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},\n  // ...\n];\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n];\n</code-example>\n<h3 id=\"lazy-loading-and-default-exports\">Lazy loading and default exports<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-and-default-exports\"><i class=\"material-icons\">link</i></a></h3>\n<p>When using <code>loadChildren</code> and <code>loadComponent</code>, the router understands and automatically unwraps dynamic <code>import()</code> calls with <code>default</code> exports. You can take advantage of this to skip the <code>.then()</code> for such lazy loading operations.</p>\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () => import('./admin/routes')},\n  // ...\n];\n\n// In admin/routes.ts:\nexport default [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n] satisfies <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[];\n</code-example>\n<h3 id=\"providing-services-to-a-subset-of-routes\">Providing services to a subset of routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3>\n<p>The lazy loading API for <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s (<code>loadChildren</code>) creates a new \"module\" injector when it loads the lazily loaded children of a route. This feature was often useful to provide services only to a subset of routes in the application. For example, if all routes under <code>/admin</code> were scoped using a <code>loadChildren</code> boundary, then admin-only services could be provided only to those routes. Doing this required using the <code>loadChildren</code> API, even if lazy loading of the routes in question was unnecessary.</p>\n<p>The Router now supports explicitly specifying additional <code>providers</code> on a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>, which allows this same scoping without the need for either lazy loading or <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. For example, scoped services within an <code>/admin</code> route structure would look like:</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {\n    path: 'admin',\n    providers: [\n      AdminService,\n      {provide: ADMIN_API_KEY, useValue: '12345'},\n    ],\n    children: [\n      {path: 'users', component: AdminUsersComponent},\n      {path: 'teams', component: AdminTeamsComponent},\n    ],\n  },\n  // ... other application routes that don't\n  //     have access to ADMIN_API_KEY or AdminService.\n];\n</code-example>\n<p>It's also possible to combine <code>providers</code> with <code>loadChildren</code> of additional routing configuration, to achieve the same effect of lazy loading an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> with additional routes and route-level providers. This example configures the same providers/child routes as above, but behind a lazy loaded boundary:</p>\n<code-example language=\"ts\">\n// Main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n</code-example>\n<p>Note the use of an empty-path route to host <code>providers</code> that are shared among all the child routes.</p>\n<p><code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> can be used to import existing NgModule-based DI configuration into route <code>providers</code> as well.</p>\n<h2 id=\"advanced-topics\">Advanced topics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n<p>This section goes into more details that are relevant only to more advanced usage patterns. You can safely skip this section when learning about standalone components, directives, and pipes for the first time. </p>\n<h3 id=\"standalone-components-for-library-authors\">Standalone components for library authors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n<p>Standalone components, directives, and pipes can be exported from <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s that import them:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ImageCarouselComponent, ImageSlideComponent],\n  exports: [ImageCarouselComponent, ImageSlideComponent],\n})\nexport class CarouselModule {}\n</code-example>\n<p>This pattern is useful for Angular libraries that publish a set of cooperating directives. In the above example, both the <code>ImageCarouselComponent</code> and <code>ImageSlideComponent</code> need to be present in a template to build up one logical \"carousel widget\". </p>\n<p>As an alternative to publishing a <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, library authors might want to export an array of cooperating directives:</p>\n<code-example language=\"ts\">\nexport const CAROUSEL_DIRECTIVES = [ImageCarouselComponent, ImageSlideComponent] as const;\n</code-example>\n<p>Such an array could be imported by applications using <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s and added to the <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>. Please note the presence of the TypeScript’s <code>as const</code> construct: it gives Angular compiler additional information required for proper compilation and is a recommended practice (as it makes the exported array immutable from the TypeScript point of view).</p>\n<h3 id=\"dependency-injection-and-injectors-hierarchy\">Dependency injection and injectors hierarchy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3>\n<p>Angular applications can configure dependency injection by specifying a set of available providers. In a typical application, there are two different injector types:</p>\n<ul>\n<li><strong>module injector</strong> with providers configured in <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> or <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code>. Those application-wide providers are visible to all components in as well as to other services configured in a module injector.</li>\n<li><strong>node injectors</strong> configured in <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> or <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code>. Those providers are visible to a given component and all its children only.</li>\n</ul>\n<h4 id=\"environment-injectors\">Environment injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4>\n<p>Making <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s optional will require new ways of configuring \"module\" injectors with application-wide providers (for example, <a href=\"/api/common/http/HttpClient\">HttpClient</a>). In the standalone application (one created with <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>), “module” providers can be configured during the bootstrap process, in the <code>providers</code> option: </p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n</code-example>\n<p>The new bootstrap API gives us back the means of configuring “module injectors” without using <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. In this sense, the “module” part of the name is no longer relevant, and we’ve decided to introduce a new term: “environment injectors”. </p>\n<p>Environment injectors can be configured using one of the following:</p>\n<ul>\n<li><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> (in applications bootstrapping through an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>);</li>\n<li><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>(in both the NgModule-based and the “standalone” applications);</li>\n<li><code>providers</code> option in the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> call (in fully “standalone” applications);</li>\n<li><code>providers</code> field in a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> configuration.</li>\n</ul>\n<p>Angular v14 introduces a new TypeScript type <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> to represent this new naming. The accompanying <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API makes it possible to create environment injectors programmatically: </p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>} from '@angular/core';\n\nconst parentInjector = … // existing environment injector\nconst childInjector = <a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([{provide: PhotosService, useClass: CustomPhotosService}], parentInjector);\n</code-example>\n<p>Environment injectors have one additional capability: they can execute initialization logic when an environment injector gets created (similar to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> constructors that get executed when a module injector is created):</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>, <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>} from '@angular/core';\n\n<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([\n{provide: PhotosService, useClass: CustomPhotosService},\n{provide: <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>, useValue: () => {\n        console.log(\"This function runs when this <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a> gets created\");\n}}\n]);\n</code-example>\n<h4 id=\"standalone-injectors\">Standalone injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4>\n<p>In reality, the dependency injectors hierarchy is slightly more elaborate in applications using standalone components. Let’s consider the following example:</p>\n<code-example language=\"ts\">\n// an existing \"datepicker\" component with an <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n        selector: 'datepicker',\n        template: '...',\n})\nclass DatePickerComponent {\n  constructor(private calendar: CalendarService) {}\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n        declarations: [DatePickerComponent],\n        exports: [DatePickerComponent],\n        providers: [CalendarService],\n})\nclass DatePickerModule {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n        selector: 'date-modal',\n        template: '&#x3C;datepicker>&#x3C;/datepicker>',\n        standalone: true,\n        imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n</code-example>\n<p>In the above example, the component <code>DateModalComponent</code> is standalone - it can be consumed directly and has no NgModule which needs to be imported in order to use it. However, <code>DateModalComponent</code> has a dependency, the <code>DatePickerComponent,</code> which is imported via its NgModule (the <code>DatePickerModule</code>). This NgModule may declare providers (in this case: <code>CalendarService</code>) which are required for the <code>DatePickerComponent</code> to function correctly.</p>\n<p>When Angular creates a standalone component, it needs to know that the current injector has all the necessary services for the standalone component's dependencies, including those based on NgModules. To guarantee that, in some cases Angular will create a new \"standalone injector\" as a child of the current environment injector. Today, this happens for all bootstrapped standalone components: it will be a child of the root environment injector. The same rule applies to the dynamically created (for example, by the router or the <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API) standalone components. </p>\n<p>A separate standalone injector is created to ensure that providers imported by a standalone component are “isolated” from the rest of the application. This lets us think of standalone components as truly self-contained pieces that can’t “leak” their implementation details to the rest of the application.</p>\n<h4 id=\"resolve-circular-dependencies-with-a-forward-class-reference\">Resolve circular dependencies with a forward class reference<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\"><i class=\"material-icons\">link</i></a></h4>\n<p>The order of class declaration matters in TypeScript. You can't refer directly to a class until it's been defined.</p>\n<p>This isn't usually a problem but sometimes circular references are unavoidable. For example, when class 'A' refers to class 'B' and 'B' refers to 'A'. One of them has to be defined first.</p>\n<p>The Angular <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> function creates an indirect reference that Angular can resolve later. </p>\n<p>For example, this situation happens when a standalone parent component imports a standalone child component and vice-versa. You can resolve this circular dependency issue by using the <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> function.</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true, \n  imports: [ChildComponent],\n  selector: 'app-parent',\n  template: `&#x3C;app-child [hideParent]=\"hideParent\">&#x3C;/app-child>`,\n})\nexport class ParentComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  imports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => ParentComponent)],\n  selector: 'app-child',\n  template: `&#x3C;app-parent *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!hideParent\">&#x3C;/app-parent>`,\n})\nexport class ChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n</code-example>\n<div class=\"alert is-important\">\n<p>This kind of imports may result in an infinite recursion during component instantiation. Make sure that this recursion has an exit condition that stops it at some point.</p>\n</div>\n\n  \n</div>\n\n<!-- links to this doc:\n - api/common/NgOptimizedImage\n - api/core/Component\n - api/core/Directive\n - api/core/Pipe\n - api/core/createEnvironmentInjector\n - api/core/importProvidersFrom\n - api/platform-browser\n - api/platform-browser/bootstrapApplication\n - guide/architecture-components\n - guide/deprecations\n - guide/glossary\n - guide/pipe-template\n - guide/pipes\n - guide/pipes-transform-data\n - guide/standalone-migration\n - guide/update-to-version-15\n-->\n<!-- links from this doc:\n - /api/common/http/HttpClient\n - api/common/CommonModule\n - api/common/NgIf\n - api/core/Component\n - api/core/Component#viewProviders\n - api/core/Directive#providers\n - api/core/ENVIRONMENT_INITIALIZER\n - api/core/EnvironmentInjector\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Provider\n - api/core/ViewContainerRef\n - api/core/createEnvironmentInjector\n - api/core/forwardRef\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - api/router/ROUTES\n - api/router/Route\n - api/router/provideRouter\n - guide/standalone-components#advanced-topics\n - guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\n - guide/standalone-components#configuring-dependency-injection\n - guide/standalone-components#creating-standalone-components\n - guide/standalone-components#dependency-injection-and-injectors-hierarchy\n - guide/standalone-components#environment-injectors\n - guide/standalone-components#getting-started-with-standalone-components\n - guide/standalone-components#lazy-loading-a-standalone-component\n - guide/standalone-components#lazy-loading-and-default-exports\n - guide/standalone-components#lazy-loading-many-routes-at-once\n - guide/standalone-components#providing-services-to-a-subset-of-routes\n - guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\n - guide/standalone-components#routing-and-lazy-loading\n - guide/standalone-components#standalone-components-for-library-authors\n - guide/standalone-components#standalone-injectors\n - guide/standalone-components#the-standalone-flag-and-component-imports\n - guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\n - guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\n-->"
}