{
  "id": "guide/rxjs-interop",
  "title": "RxJS Interop",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"rxjs-interop\">RxJS Interop<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-important\">\n<p>The RxJS Interop package is available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. It's ready for you to try, but it might change before it is stable.</p>\n</div>\n<p>Angular's <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> package which provides useful utilities to integrate <a href=\"/guide/signals\">Angular Signals</a> with RxJS Observables.</p>\n<h2 id=\"tosignal\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#tosignal\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> function creates a signal which tracks the value of an Observable. It behaves similarly to the <code>async</code> pipe in templates, but is more flexible and can be used anywhere in an application.</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>} from '@angular/core';\nimport {<a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a>} from '@angular/common';\nimport {interval} from 'rxjs';\nimport { <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a> } from '@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  template: `{{ counter() }}`,\n})\nexport class Ticker {\n  counterObservable = interval(1000);\n\n  // Get a `<a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>` representing the `counterObservable`'s value.\n  counter = <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a>(this.counterObservable, {initialValue: 0});\n}\n</code-example>\n<p>Like the <code>async</code> pipe, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> subscribes to the Observable immediately, which may trigger side effects. The subscription created by\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> automatically unsubscribes from the given Observable upon destruction of the component in which <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> is called.</p>\n<h3 id=\"initial-values\">Initial values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3>\n<p>Observables may not produce a value synchronously on subscription, but signals always require a current value. There are several ways to deal with this \"initial\" value of <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> signals.</p>\n<h4 id=\"the-initialvalue-option\">The <code>initialValue</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4>\n<p>As in the example above, the <code>initialValue</code> option specifies the value the signal should return before the Observable emits for the first time.</p>\n<h4 id=\"undefined-initial-values\"><code>undefined</code> initial values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4>\n<p>If <code>initialValue</code> is omitted, the signal returned by <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> returns <code>undefined</code> until the Observable emits. This is similar to the <code>async</code> pipe's behavior of returning <code>null</code>.</p>\n<h4 id=\"the-requiresync-option\">The <code>requireSync</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4>\n<p>Some Observables are known to emit synchronously, such as <code>BehaviorSubject</code>. In those cases, you can specify the <code>requireSync: true</code> option.</p>\n<p>When <code>requiredSync</code> is <code>true</code>, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> enforces that the Observable emits synchronously on subscription. This guarantees that the signal always has a value, and no <code>undefined</code> type or initial value is required.</p>\n<h3 id=\"manualcleanup\"><code>manualCleanup</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#manualcleanup\"><i class=\"material-icons\">link</i></a></h3>\n<p>By default, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> automatically unsubscribes from the Observable upon destruction of the context in which it's created. For example, if <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> is called during creation of a component, it cleans up its subscription when the component is destroyed.</p>\n<p>The <code>manualCleanup</code> option disables this automatic cleanup. You can use this setting for Observables that complete themselves naturally.</p>\n<h3 id=\"error-and-completion\">Error and Completion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3>\n<p>If an Observable used in <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> produces an error, that error is thrown when the signal is read. It's recommended that errors be handled upstream in the Observable and turned into a value instead (which might indicate to the template that an error page needs to be displayed). This can be done using the <code>catchError</code> operator in RxJS.</p>\n<p>If an Observable used in <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> completes, the signal continues to return the most recently emitted value before completion.</p>\n<h4 id=\"the-rejecterrors-option\">The <code>rejectErrors</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-rejecterrors-option\"><i class=\"material-icons\">link</i></a></h4>\n<p><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>'s default behavior for errors propagates the error channel of the <code>Observable</code> through to the signal. An alternative approach is to reject errors entirely, using the <code>rejectErrors</code> option of <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>. With this option, errors are thrown back into RxJS where they'll be trapped as uncaught exceptions in the global application error handler. Since Observables no longer produce values after they error, the signal returned by <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> will keep returning the last successful value received from the Observable forever. This is the same behavior as the <code>async</code> pipe has for errors.</p>\n<h2 id=\"toobservable\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> utility creates an <code>Observable</code> which tracks the value of a signal. The signal's value is monitored with an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>, which emits the value to the Observable when it changes.</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> } from '@angular/core';\nimport { <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a> } from '@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nexport class SearchResults {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&#x3C;string> = inject(QueryService).query;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(this.query);\n\n  results$ = this.query$.pipe(\n    switchMap(<a href=\"api/animations/query\" class=\"code-anchor\">query</a> => this.http.get('/search?q=' + <a href=\"api/animations/query\" class=\"code-anchor\">query</a> ))\n  );\n}\n</code-example>\n<p>As the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> signal changes, the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable emits the latest query and triggers a new HTTP request.</p>\n<h3 id=\"injection-context\">Injection context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n<p><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> by default needs to run in an <a href=\"/guide/dependency-injection-context\">injection context</a>, such as during construction of a component or service. If an injection context is not available, an <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> can instead be explicitly specified.</p>\n<h3 id=\"timing-of-toobservable\">Timing of <code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#timing-of-toobservable\"><i class=\"material-icons\">link</i></a></h3>\n<p><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> uses an effect to track the value of the signal in a <code>ReplaySubject</code>. On subscription, the first value (if available) may be emitted synchronously, and all subsequent values will be asynchronous.</p>\n<p>Unlike Observables, signals never provide a synchronous notification of changes. Even if your code updates a signal's value multiple times, effects which depend on its value run only after the signal has \"settled\".</p>\n<code-example language=\"ts\">\nconst obs$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(mySignal);\nobs$.subscribe((value) => console.log(value));\n\nmySignal.set(1);\nmySignal.set(2);\nmySignal.set(3);\n</code-example>\n<p>Here, only the last value (3) will be logged.</p>\n\n  \n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/dependency-injection-context\n - /guide/releases#developer-preview\n - /guide/signals\n - api/animations/query\n - api/common/AsyncPipe\n - api/core/Component\n - api/core/Injector\n - api/core/Signal\n - api/core/effect\n - api/core/rxjs-interop\n - api/core/rxjs-interop/toObservable\n - api/core/rxjs-interop/toSignal\n - api/core/signal\n - guide/rxjs-interop#error-and-completion\n - guide/rxjs-interop#initial-values\n - guide/rxjs-interop#injection-context\n - guide/rxjs-interop#manualcleanup\n - guide/rxjs-interop#rxjs-interop\n - guide/rxjs-interop#the-initialvalue-option\n - guide/rxjs-interop#the-rejecterrors-option\n - guide/rxjs-interop#the-requiresync-option\n - guide/rxjs-interop#timing-of-toobservable\n - guide/rxjs-interop#toobservable\n - guide/rxjs-interop#tosignal\n - guide/rxjs-interop#undefined-initial-values\n-->"
}