{
  "id": "guide/http-interceptor-use-cases",
  "title": "HTTP -  interceptor use-cases",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"http----interceptor-use-cases\">HTTP -  interceptor use-cases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1>\n<p>Following are a number of common uses for interceptors.</p>\n<h2 id=\"set-default-headers\">Set default headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2>\n<p>Apps often use an interceptor to set default headers on outgoing requests.</p>\n<p>The sample app has an <code>AuthService</code> that produces an authorization token.\nHere is its <code>AuthInterceptor</code> that injects that service to get the token and adds an authorization header with that token to every outgoing request:</p>\n<code-example header=\"app/http-interceptors/auth-interceptor.ts\" path=\"http/src/app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&#x3C;any>, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p>The practice of cloning a request to set new headers is so common that there's a <code>setHeaders</code> shortcut for it:</p>\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p>An interceptor that alters headers can be used for a number of different operations, including:</p>\n<ul>\n<li>Authentication/authorization</li>\n<li>Caching behavior; for example, <code>If-Modified-Since</code></li>\n<li>XSRF protection</li>\n</ul>\n<h2 id=\"log-request-and-response-pairs\">Log request and response pairs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2>\n<p>Because interceptors can process the request and response <em>together</em>, they can perform tasks such as timing and logging an entire HTTP operation.</p>\n<p>Consider the following <code>LoggingInterceptor</code>, which captures the time of the request,\nthe time of the response, and logs the outcome with the elapsed time\nwith the injected <code>MessageService</code>.</p>\n<code-example header=\"app/http-interceptors/logging-interceptor.ts)\" path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\">\nimport { finalize, tap } from 'rxjs';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&#x3C;any>, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) => (ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : ''),\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error: (_error) => (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() => {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p>The RxJS <code>tap</code> operator captures whether the request succeeded or failed.\nThe RxJS <code>finalize</code> operator is called when the response observable either returns an error or completes and reports the outcome to the <code>MessageService</code>.</p>\n<p>Neither <code>tap</code> nor <code>finalize</code> touch the values of the observable stream returned to the caller.</p>\n<p><a id=\"custom-json-parser\"></a></p>\n<h2 id=\"custom-json-parsing\">Custom JSON parsing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2>\n<p>Interceptors can be used to replace the built-in JSON parsing with a custom implementation.</p>\n<p>The <code>CustomJsonInterceptor</code> in the following example demonstrates how to achieve this.\nIf the intercepted request expects a <code>'json'</code> response, the <code>responseType</code> is changed to <code>'text'</code> to disable the built-in JSON parsing.\nThen the response is parsed via the injected <code>JsonParser</code>.</p>\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-interceptor\">\n// The JsonParser class acts as a base class for custom parsers and as the DI token.\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport abstract class JsonParser {\n  abstract parse(text: string): any;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private jsonParser: JsonParser) {}\n\n  intercept(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&#x3C;any>, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    if (httpRequest.responseType === 'json') {\n      // If the expected response type is JSON then handle it here.\n      return this.handleJsonResponse(httpRequest, next);\n    } else {\n      return next.handle(httpRequest);\n    }\n  }\n\n  private handleJsonResponse(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&#x3C;any>, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Override the responseType to disable the default JSON parsing.\n    httpRequest = httpRequest.clone({responseType: 'text'});\n    // Handle the response using the custom parser.\n    return next.handle(httpRequest).pipe(map(event => this.parseJsonResponse(event)));\n  }\n\n  private parseJsonResponse(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&#x3C;any>) {\n    if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> &#x26;&#x26; typeof event.body === 'string') {\n      return event.clone({body: this.jsonParser.parse(event.body)});\n    } else {\n      return event;\n    }\n  }\n}\n\n</code-example>\n<p>You can then implement your own custom <code>JsonParser</code>.\nHere is a custom JsonParser that has a special date reviver.</p>\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-parser\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonParser implements JsonParser {\n  parse(text: string): any {\n    return JSON.parse(text, dateReviver);\n  }\n}\n\nfunction dateReviver(key: string, value: any) {\n  /* . . . */\n}\n\n</code-example>\n<p>Finally, provide the <code>CustomParser</code> along with the <code>CustomJsonInterceptor</code> in that same <code>httpInterceptorProviders</code> array.</p>\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"custom-json-interceptor\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CustomJsonInterceptor, multi: true },\n{ provide: JsonParser, useClass: CustomJsonParser },\n\n</code-example>\n<p><a id=\"caching\"></a></p>\n<h2 id=\"cache-requests\">Cache requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2>\n<p>Interceptors can handle requests by themselves, without forwarding to <code>next.handle()</code>.</p>\n<p>For example, you might decide to cache certain requests and responses to improve performance.\nYou can delegate caching to an interceptor without disturbing your existing data services.</p>\n<p>The <code>CachingInterceptor</code> in the following example demonstrates this approach.</p>\n<code-example header=\"app/http-interceptors/caching-interceptor.ts)\" path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&#x3C;any>, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p>The <code>isCacheable()</code> function determines if the request is cacheable.\nIn this sample, only GET requests to the package search API are cacheable.</p>\n</li>\n<li>\n<p>If the request is not cacheable, the interceptor forwards the request to the next handler in the chain</p>\n</li>\n<li>\n<p>If a cacheable request is found in the cache, the interceptor returns an <code>of()</code> <em>observable</em> with the cached response, by-passing the <code>next</code> handler and all other interceptors downstream</p>\n</li>\n<li>\n<p>If a cacheable request is not in cache, the code calls <code>sendRequest()</code>.\nThis function forwards the request to <code>next.handle()</code> which ultimately calls the server and returns the server's response.</p>\n</li>\n</ul>\n<p><a id=\"send-request\"></a></p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&#x3C;any>,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&#x3C;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&#x3C;any>> {\n  return next.handle(req).pipe(\n    tap(event => {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Notice how <code>sendRequest()</code> intercepts the response on its way back to the application.\nThis method pipes the response through the <code>tap()</code> operator, whose callback adds the response to the cache.</p>\n<p>The original response continues untouched back up through the chain of interceptors to the application caller.</p>\n<p>Data services, such as <code>PackageSearchService</code>, are unaware that some of their <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests actually return cached responses.</p>\n</div>\n<p><a id=\"cache-refresh\"></a></p>\n<h2 id=\"use-interceptors-to-request-multiple-values\">Use interceptors to request multiple values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method normally returns an observable that emits a single value, either the data or an error.\nAn interceptor can change this to an observable that emits <a href=\"guide/observables\">multiple values</a>.</p>\n<p>The following revised version of the <code>CachingInterceptor</code> optionally returns an observable that immediately emits the cached response, sends the request on to the package search API, and emits again later with the updated search results.</p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>The <em>cache-then-refresh</em> option is triggered by the presence of a custom <code>x-refresh</code> header.</p>\n<p>A checkbox on the <code>PackageSearchComponent</code> toggles a <code>withRefresh</code> flag, which is one of the arguments to <code>PackageSearchService.search()</code>.\nThat <code>search()</code> method creates the custom <code>x-refresh</code> header and adds it to the request before calling <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>.</p>\n</div>\n<p>The revised <code>CachingInterceptor</code> sets up a server request whether there's a cached value or not, using the same <code>sendRequest()</code> method described <a href=\"guide/http-interceptor-use-cases#send-request\">above</a>.\nThe <code>results$</code> observable makes the request when subscribed.</p>\n<ul>\n<li>If there's no cached value, the interceptor returns <code>results$</code>.</li>\n<li>If there is a cached value, the code <em>pipes</em> the cached response onto <code>results$</code>. This produces a recomposed observable that emits two responses, so subscribers will see a sequence of these two responses:  </li>\n<li>The cached response that's emitted immediately</li>\n<li>The response from the server, that's emitted later</li>\n</ul>\n<p><a id=\"report-progress\"></a></p>\n\n  <div class=\"reviewed\">Last reviewed on Tue Nov 08 2022</div>\n</div>\n\n<!-- links to this doc:\n - guide/http-intercept-requests-and-responses\n - guide/http-optimize-server-interaction\n-->\n<!-- links from this doc:\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/http-interceptor-use-cases#cache-requests\n - guide/http-interceptor-use-cases#custom-json-parsing\n - guide/http-interceptor-use-cases#http----interceptor-use-cases\n - guide/http-interceptor-use-cases#log-request-and-response-pairs\n - guide/http-interceptor-use-cases#send-request\n - guide/http-interceptor-use-cases#set-default-headers\n - guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\n - guide/observables\n-->"
}