{
  "id": "guide/signal-inputs",
  "title": "Signal inputs",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"signal-inputs\">Signal inputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#signal-inputs\"><i class=\"material-icons\">link</i></a></h1>\n<p>Signal inputs allow values to be bound from parent components.\nThose values are exposed using a <code><a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a></code> and can change during the lifecycle of your component.</p>\n<div class=\"alert is-helpful\">\n<p>Signal inputs are currently in <a href=\"/guide/releases#developer-preview\">developer preview</a>.</p>\n</div>\n<p>Angular supports two variants of inputs:</p>\n<p><strong>Optional inputs</strong>\nInputs are optional by default, unless you use <code>input.required</code>.\nYou can specify an explicit initial value, or Angular will use <code>undefined</code> implicitly.</p>\n<p><strong>Required inputs</strong>\nRequired inputs always have a value of the given input type.\nThey are declared using the <code>input.required</code> function.</p>\n<code-example language=\"typescript\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, input} from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class MyComp {\n  // optional\n  firstName = input&#x3C;string>();         // <a href=\"api/core/InputSignal\" class=\"code-anchor\">InputSignal</a>&#x3C;string|undefined>\n  age = input(0);                      // <a href=\"api/core/InputSignal\" class=\"code-anchor\">InputSignal</a>&#x3C;number>\n\n  // required\n  lastName = input.required&#x3C;string>(); // <a href=\"api/core/InputSignal\" class=\"code-anchor\">InputSignal</a>&#x3C;string>\n}\n</code-example>\n<p>An input is automatically recognized by Angular whenever you use the <code>input</code> or <code>input.required</code> functions as initializer of class members.</p>\n<h2 id=\"aliasing-an-input\">Aliasing an input<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#aliasing-an-input\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular uses the class member name as the name of the input.\nYou can alias inputs to change their public name to be different.</p>\n<code-example language=\"typescript\">\nclass StudentDirective {\n  age = input(0, {alias: 'studentAge'});\n}\n</code-example>\n<p>This allows users to bind to your input using <code>[studentAge]</code>, while inside your component you can access the input values using <code>this.age</code>.</p>\n<h2 id=\"using-in-templates\">Using in templates<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#using-in-templates\"><i class=\"material-icons\">link</i></a></h2>\n<p>Signal inputs are read-only signals.\nAs with signals declared via <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a>()</code>, you access the current value of the input by calling the input signal.</p>\n<code-example language=\"html\">\n&#x3C;p>First name: {{firstName()}}&#x3C;/p>\n&#x3C;p>Last name: {{lastName()}}&#x3C;/p>\n</code-example>\n<p>This access to the value is captured in reactive contexts and can notify active consumers, like Angular itself, whenever the input value changes.</p>\n<p>An input signal in practice is a trivial extension of signals that you know from <a href=\"/guide/signals\">the signals guide</a>.</p>\n<code-example language=\"typescript\">\nexport class <a href=\"api/core/InputSignal\" class=\"code-anchor\">InputSignal</a>&#x3C;T> extends <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&#x3C;T> { ... }`.\n</code-example>\n<h2 id=\"deriving-values\">Deriving values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#deriving-values\"><i class=\"material-icons\">link</i></a></h2>\n<p>As with signals, you can derive values from inputs using <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code>.</p>\n<code-example language=\"typescript\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, input, <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>} from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class MyComp {\n  age = input(0);\n\n  // age multiplied by two.\n  ageMultiplied = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() => this.age() * 2);\n}\n</code-example>\n<p>Computed signals memoize values.\nSee more details in the <a href=\"/guide/signals#computed-signals\">dedicated section for computed</a>.</p>\n<h2 id=\"monitoring-changes\">Monitoring changes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#monitoring-changes\"><i class=\"material-icons\">link</i></a></h2>\n<p>With signal inputs, users can leverage the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> function.\nThe function will execute whenever the input changes.</p>\n<p>Consider the following example.\nThe new value is printed to the console whenever the <code>firstName</code> input changes.</p>\n<code-example language=\"typescript\">\nimport {input, <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>} from '@angular/core';\n\nclass MyComp {\n  firstName = input.required&#x3C;string>();\n\n  constructor() {\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n      console.log(this.firstName());\n    });\n  }\n}\n</code-example>\n<p>The <code>console.log</code> function is invoked every time the <code>firstName</code> input changes.\nThis will happen as soon as <code>firstName</code> is available, and for subsequent changes during the lifetime of <code>MyComp</code>.</p>\n<h2 id=\"value-transforms\">Value transforms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#value-transforms\"><i class=\"material-icons\">link</i></a></h2>\n<p>You may want to coerce or parse input values without changing the meaning of the input.\nTransforms convert the raw value from parent templates to the expected input type.\nTransforms should be <a href=\"https://en.wikipedia.org/wiki/Pure_function\">pure functions</a>.</p>\n<code-example language=\"typescript\">\nclass MyComp {\n  disabled = input(false, {\n    transform: (value: boolean|string) => typeof value === 'string' ? value === '' : value,\n  });\n}\n</code-example>\n<p>In the example above, you are declaring an input named <code>disabled</code> that is accepting values of type <code>boolean</code> and <code>string</code>.\nThis is captured by the explicit parameter type of <code>value</code> in the <code>transform</code> option.\nThese values are then parsed to a <code>boolean</code> with the transform, resulting in booleans.</p>\n<p>That way, you are only dealing with <code>boolean</code> inside your component when calling <code>this.disabled()</code>, while users of your component can pass an empty string as a shorthand to mark your component as disabled.</p>\n<code-example language=\"html\">\n&#x3C;my-custom-comp disabled>\n</code-example>\n<div class=\"alert is-important\">\n<p>Do not use transforms if they change the meaning of the input, or if they are <a href=\"https://en.wikipedia.org/wiki/Pure_function#Impure_functions\">impure</a>.</p>\n<p>Instead, use <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> for transformations with different meaning, or an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> for impure code that should run whenever the input changes.</p>\n</div>\n<h2 id=\"why-should-we-use-signal-inputs-and-not-input\">Why should we use signal inputs and not <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signal-inputs#why-should-we-use-signal-inputs-and-not-input\"><i class=\"material-icons\">link</i></a></h2>\n<p>Signal inputs are a reactive alternative to decorator-based <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>.</p>\n<p>In comparison to decorator-based <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>, signal inputs provide numerous benefits:</p>\n<ol>\n<li>Signal inputs are more <strong>type safe</strong>:\n<br>• Required inputs do not require initial values, or tricks to tell TypeScript that an input <em>always</em> has a value.\n<br>• Transforms are automatically checked to match the accepted input values.</li>\n<li>Signal inputs, when used in templates, will <strong>automatically</strong> mark <code>OnPush</code> components as dirty.</li>\n<li>Values can be easily <strong>derived</strong> whenever an input changes using <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code>.</li>\n<li>Easier and more local monitoring of inputs using <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> instead of <code>ngOnChanges</code> or setters.</li>\n</ol>\n\n  \n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/releases#developer-preview\n - /guide/signals\n - /guide/signals#computed-signals\n - api/core/Component\n - api/core/Input\n - api/core/InputSignal\n - api/core/Signal\n - api/core/computed\n - api/core/effect\n - api/core/signal\n - guide/signal-inputs#aliasing-an-input\n - guide/signal-inputs#deriving-values\n - guide/signal-inputs#monitoring-changes\n - guide/signal-inputs#signal-inputs\n - guide/signal-inputs#using-in-templates\n - guide/signal-inputs#value-transforms\n - guide/signal-inputs#why-should-we-use-signal-inputs-and-not-input\n - https://en.wikipedia.org/wiki/Pure_function\n - https://en.wikipedia.org/wiki/Pure_function#Impure_functions\n-->"
}