{
  "id": "guide/rx-library",
  "title": "The RxJS library",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"the-rxjs-library\">The RxJS library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a></h1>\n<p>Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change (<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">Wikipedia</a>).\nRxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code.\nSee the <a href=\"https://rxjs.dev/guide/overview\">RxJS Docs</a>.</p>\n<p>RxJS provides an implementation of the <code>Observable</code> type, which is needed until the type becomes part of the language and until browsers support it.\nThe library also provides utility functions for creating and working with observables.\nThese utility functions can be used for:</p>\n<ul>\n<li>Converting existing code for async operations into observables</li>\n<li>Iterating through the values in a stream</li>\n<li>Mapping values to different types</li>\n<li>Filtering streams</li>\n<li>Composing multiple streams</li>\n</ul>\n<h2 id=\"observable-creation-functions\">Observable creation functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functions\"><i class=\"material-icons\">link</i></a></h2>\n<p>RxJS offers a number of functions that can be used to create new observables.</p>\n<p>These functions can simplify the process of creating observables from things such as events, timers, and promises.\nFor example:</p>\n<code-example header=\"Create an observable from a promise\" path=\"rx-library/src/simple-creation.1.ts\" region=\"promise\">\nimport { from, Observable } from 'rxjs';\n\n// Create an Observable out of a promise\nconst data = from(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> result\ndata.subscribe({\n  next(response) { console.log(response); },\n  error(err) { console.error('Error: ' + err); },\n  complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example header=\"Create an observable from a counter\" path=\"rx-library/src/simple-creation.2.ts\" region=\"interval\">\nimport { interval } from 'rxjs';\n\n// Create an Observable that will publish a value on an interval\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\nconst subscription = secondsCounter.subscribe(n =>\n  console.log(`It's been ${n + 1} seconds since subscribing!`));\n\n\n</code-example>\n<code-example header=\"Create an observable from an event\" path=\"rx-library/src/simple-creation.3.ts\" region=\"event\">\nimport { fromEvent } from 'rxjs';\n\nconst el = document.getElementById('my-element')!;\n\n// Create an Observable that will publish mouse movements\nconst mouseMoves = fromEvent&#x3C;MouseEvent>(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\nconst subscription = mouseMoves.subscribe(evt => {\n  // Log coords of mouse movements\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  if (evt.clientX &#x3C; 40 &#x26;&#x26; evt.clientY &#x3C; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example header=\"Create an observable that creates an AJAX request\" path=\"rx-library/src/simple-creation.ts\" region=\"ajax\">\nimport { Observable } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\n\n// Create an Observable that will create an AJAX request\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\napiData.subscribe(res => console.log(res.status, res.response));\n\n</code-example>\n<h3 id=\"subject\">Subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#subject\"><i class=\"material-icons\">link</i></a></h3>\n<p>An RxJS <a href=\"https://rxjs.dev/guide/subject\"><code>Subject</code></a> is a popular way to create and control an observable of your own design.</p>\n<p>A <code>Subject</code> is a special kind of <code>Observable</code>. It is special in two important respects:</p>\n<ol>\n<li>You can push values into that <code>Observable</code> by calling its <code>next(value)</code> method.</li>\n<li>It is a <a href=\"https://rxjs.dev/guide/glossary-and-semantics#multicast\">\"multicast\"</a> observable, which means all subscribers of a <code>Subject</code> instance receive the same values from that instance.</li>\n</ol>\n<p>These aspects of <code>Subject</code> make it easy to create a <a href=\"https://en.wikipedia.org/wiki/Loose_coupling\">loosely coupled</a> message service. One part of the application can send messages through the service; other parts of the application can listen to those messages; none of the parts know about each other.</p>\n<p><a id=\"message-service\"></a></p>\n<p>Here is a <code>MessageService</code> example:\n<code-example header=\"MessageService\" path=\"rx-library/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n/** The interface for values emitted by the Message Service */\nexport interface Message {\n  type: 'Warning' | 'Error';\n  text: string;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: 'root'})\nexport class MessageService {\n  // Tip: never expose the Subject itself.\n  private messageSubject = new Subject&#x3C;Message>();\n\n  /** Observable of all messages */\n  messages$ = this.messageSubject.asObservable();\n\n  /** Add an error message to the Subject */\n  addError(text: string) {\n    this.messageSubject.next({ type: 'Error', text });\n  }\n\n  /** Add a warning message to the Subject */\n  addWarning(text: string) {\n    this.messageSubject.next({ type: 'Warning', text });\n  }\n}\n\n\n</code-example></p>\n<p>Key features:</p>\n<ul>\n<li>The <code>Subject</code> is <em>private</em>. Consumers of the service access the <code>Subject</code> through a controlled public API.</li>\n<li>The <code>messages$</code> property exposes the <code>Subject</code>'s <em>observable</em> aspect-only; a consumer cannot push values into the <code>Subject</code> through this observable.</li>\n<li>Dedicated methods (<code>addError</code> and <code>addWarning</code>) tightly manage how service consumers add values to the hidden <code>Subject</code>.</li>\n<li><code>Subject</code> values are always of the <code>Message</code> type; consumers of the <code>messages$</code> observable can rely on the shape of those values.</li>\n</ul>\n<p><a href=\"guide/rx-library#loosely-coupled-apps\">See below</a> how you can use such a service to build a loosely coupled application.</p>\n<h2 id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a></h2>\n<p><a href=\"https://rxjs.dev/guide/operators\">Operators</a> enable transformations of observable values. An operator is a function that takes an observable source and configuration options, manipulates the values from that source in some useful way, and returns a new observable of the transformed values. </p>\n<p>You can chain operators in a sequence to produce a custom observable tailored to your needs. When you subscribe to that new observable, you get the results of the intermediate transformations.</p>\n<p>RxJS offers numerous built in operators for common use cases such as <code>map()</code>, <code>filter()</code>, <code>concat()</code>, and <code>mergeMap()</code>.</p>\n<p>Here is a example that uses the <code>map</code> operator to square a sequence of integers:</p>\n<code-example header=\"Map operator\" path=\"rx-library/src/operators.ts\">\nimport { of, map } from 'rxjs';\n\n/** source observable of integers. */\nconst nums = of(1, 2, 3);\n\n/** A new squares observable created by piping through the `map` operator. */\nconst squares = nums.pipe(\n  map(num => num * num) // `map` configured with a function that squares each value.\n);\n\n// subscribe to the new observable\nsquares.subscribe(value => console.log(value));\n\n// Logs\n// 1\n// 4\n// 9\n\n</code-example>\n<p>Notice that you pass the <code>map</code> operator to the observable's <code>pipe</code> method. This is called \"piping\" the source observable through the operator.</p>\n<p>You can chain multiple operators together by adding them as parameters to the <code>pipe</code> call. The following example first <code>filters</code> for the odd integers and then squares their values in the <code>map</code>. The resulting observable emits the squares of the odd integers from the source.</p>\n<code-example header=\"Observable.pipe function\" path=\"rx-library/src/operators.2.ts\">\nimport { of, filter, map } from 'rxjs';\n\nconst squareOdd = of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n => n % 2 === 1),\n    map(n => n * n)\n  );\n\n// Subscribe to get values\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>You can create your own custom operator with the <code>pipe</code> method to encapsulate a re-usable chain of operators. The following example creates a <code>squareOddValues</code> operator and then pipes the source integers through it.</p>\n<code-example header=\"Standalone pipe function\" path=\"rx-library/src/operators.1.ts\">\nimport { of, filter, map, pipe } from 'rxjs';\n\nconst nums = of(1, 2, 3, 4, 5);\n\n// Create a function that accepts an Observable.\nconst squareOddVals = pipe(\n  filter((n: number) => n % 2 === 1),\n  map(n => n * n)\n);\n\n// Create an Observable that will run the filter and map functions\nconst squareOdd = squareOddVals(nums);\n\n// Subscribe to run the combined functions\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n</div>\n<p>Think of a sequence of operators as a recipe for the final observable — as a set of instructions for producing the values you're interested in.</p>\n<p>Remember that, by itself, the recipe doesn't do anything;\nyou need to call <code>subscribe()</code> to produce a result through the recipe.</p>\n<p><a id=\"loosely-coupled-apps\"></a></p>\n<h3 id=\"loosely-coupled-transformations\">Loosely coupled transformations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#loosely-coupled-transformations\"><i class=\"material-icons\">link</i></a></h3>\n<p>RxJS operators facilitate development of <a href=\"https://en.wikipedia.org/wiki/Loose_coupling\">loosely coupled</a> applications.\nOne part of the application can add values to an observable without knowing how the observable will be consumed or by whom.</p>\n<p>Another part of the application can pipe operators onto that observable to transform its values into a shape it finds useful.</p>\n<p>The <code>MessageService</code> example <a href=\"guide/rx-library#message-service\">described earlier</a> demonstrates these points. The <code>AppComponent</code> presents the user with buttons to add messages, either of the error or warning type. The button click handlers send those messages to the service. </p>\n<code-example header=\"AppComponent (excerpt)\" path=\"rx-library/src/app/app.component.ts\" region=\"add-messages\">\nconstructor(private messageService: MessageService) { }\n\naddError(text: string) {\n  this.messageService.addError(text);\n}\n\naddWarning(text: string) {\n  this.messageService.addWarning(text);\n}\n\n</code-example>\n<p>Neither the <code>AppComponent</code> nor the service know what will happen to those messages.</p>\n<p>Elsewhere, the <code>MessageComponent</code> filters and maps the messages into separate <code>string</code> observables, one for errors and another for warnings.</p>\n<code-example header=\"MessageComponent (excerpt)\" path=\"rx-library/src/app/message.component.ts\" region=\"observables\">\n// Observable of ALL messages\nthis.messages$ = messageService.messages$;\n\n// Derived string observable of just the error message texts\nthis.errors$ = this.messages$.pipe(\n  filter(m => m.type === 'Error'),\n  map(m => m.text),\n);\n\n// Derived string observable of just the warning message texts\nthis.warnings$ = this.messages$.pipe(\n  filter(m => m.type === 'Warning'),\n  map(m => m.text),\n);\n\n</code-example>\n<p>The component goes on to display these observables to the user.</p>\n<p>This ability to manipulate streams of asynchronous data in a loosely coupled way is perhaps the best use case for RxJS in your application.</p>\n<div class=\"alert is-helpful\">\n<p>To see this messaging example in action, try <live-example name=\"rx-library\"></live-example>.</p>\n</div>\n<h3 id=\"common-operators\">Common operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a></h3>\n<p>RxJS provides many operators, but only a handful are used frequently.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Area</th>\n<th align=\"left\">Operators</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Creation</td>\n<td align=\"left\"><code>from</code>, <code>fromEvent</code>, <code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\">Combination</td>\n<td align=\"left\"><code>combineLatest</code>, <code>concat</code>, <code>merge</code>, <code>startWith</code> , <code>withLatestFrom</code>, <code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\">Filtering</td>\n<td align=\"left\"><code>debounceTime</code>, <code>distinctUntilChanged</code>, <code>filter</code>, <code>take</code>, <code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\">Transformation</td>\n<td align=\"left\"><code>bufferTime</code>, <code>concatMap</code>, <code>map</code>, <code>mergeMap</code>, <code>scan</code>, <code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\">Utility</td>\n<td align=\"left\"><code>startWith</code>, <code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\">Multicasting</td>\n<td align=\"left\"><code>shareReplay</code></td>\n</tr>\n</tbody>\n</table>\n<p>For a complete list of operators and usage samples, visit the <a href=\"https://rxjs.dev/api\">RxJS API Documentation</a>.</p>\n<h2 id=\"error-handling\">Error handling<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n<p>In addition to the <code>error()</code> handler that you provide on subscription, RxJS provides the <code>catchError</code> operator that lets you handle known errors in the observable recipe.</p>\n<p>For instance, suppose you have an observable that makes an API request and maps the response from the server.</p>\n<p>If the server returns an error or the value doesn't exist, an error is produced.\nIf you catch this error with the <code>catchError</code> operator and return an observable of a default value, your stream continues to process values rather than erroring out.</p>\n<p>Here's an example:</p>\n<code-example header=\"catchError operator\" path=\"rx-library/src/error-handling.ts\">\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError } from 'rxjs/operators';\n\n// Return good response from the API.\n// If the response is bad, throw an error.\nconst apiData = ajax('/api/data').pipe(\n  map((res: any) => {\n    if (!res?.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  /*\n   * Catch the error, either from the AJAX call or from the map operator,\n   * and return an observable of empty array.\n   * The `catchError` argument must be a function that returns an observable.\n   */\n  catchError(() => of([]))\n);\n\napiData.subscribe({\n  next(x: T) { console.log('data: ', x); },\n  error() { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 id=\"multiple-subscribers\">Multiple Subscribers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#multiple-subscribers\"><i class=\"material-icons\">link</i></a></h3>\n<p>Most observables are \"<strong><em>unicast</em></strong>\", which means that each new subscriber gets its own execution of that observable. Whatever is driving the source observable starts over again for the added subscriber.</p>\n<p>The  RxJS <code>interval()</code> function in the following example produces a <em>unicast</em> observable that emits an integer every half second.\n<code-example header=\"unicast\" path=\"rx-library/src/app/uni-multi-cast.component.ts\" region=\"unicast-observable\">\n/** Unicast observable that emits integers every 1/2 second. */\nnumbers$: Observable&#x3C;number> = interval(500);\n\n</code-example></p>\n<p>Each new subscriber receives a fresh round of integers starting from zero.</p>\n<blockquote>\n<p><strong>Unicast Subscriber(s)</strong>:<br>\nUnicast Subscriber #1 received 9<br>\nUnicast Subscriber #2 received 5<br>\nUnicast Subscriber #3 received 0</p>\n</blockquote>\n<p>Most observables are <em>unicast</em> like <code>interval</code>.\nFor example, the observable returned from Angular's <a href=\"guide/understanding-communicating-with-http\"><code>HttpClient.get()</code></a> is <em>unicast</em>. It makes a fresh call to the server every time you subscribe to it. </p>\n<p>That <em>may</em> be what you intend.\nBut sometimes you want the same source of values to be shared with everyone who subscribes. For example, once you have asked <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> to return some configuration, you probably don't want to make another request to the server the next time you subscribe; you want the same configuration that you got last time. </p>\n<p>You want that <code>HttpClient.get</code> observable to behave like a \"<strong><em>multicast</em></strong>\" observable.</p>\n<p>A <code>Subject</code>, such as the one in the <code>MessageService</code>, is a <em>multicast</em> observable by design. Its subscribers always get the same, latest message.</p>\n<p>We need to do something special to turn the <em>unicast</em> observables from <code>interval</code> and <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> into <em>multicast</em> observables. A typical solution is to add the <a href=\"https://rxjs.dev/api/index/function/shareReplay\"><code>shareReplay()</code></a> operator to the pipe; add it to the end if you have a list of operators.</p>\n<p>Here is <code>interval</code> again, this time with <code>shareReplay</code>:</p>\n<code-example header=\"multicast with shareReplay\" path=\"rx-library/src/app/uni-multi-cast.component.ts\" region=\"shareReplay-observable\">\n/** Multicast the interval by extending `numbers$` with `shareReplay` */\nmultiCastNumber$ = this.numbers$.pipe(\n  // Replay 1 item; never forgets, never completes.\n  shareReplay({ bufferSize: 1, refCount: false })\n);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>  The <code>bufferSize=1</code> option means that new subscribers receive the latest value (the buffered value) emitted previously by the observable.</p>\n<p>  The <code>refCount=false</code> option means that if <em>everyone unsubscribes</em> and then someone new subscribes, that new subscriber gets the last emitted value.</p>\n<p>  If <code>refCount</code> is <code>true</code>, when everyone unsubscribes and then someone new subscribes, that new subscriber initiates a fresh execution of the source observable. The <code>interval</code> example will restart from zero.</p>\n</div>\n<p>Each new subscriber receives the same integer last emitted by the observable.</p>\n<blockquote>\n<p><strong>Multicast ShareReplay Subscriber(s)</strong>:<br>\nShareReplay Subscriber #1 received 9<br>\nShareReplay Subscriber #2 received 9<br>\nShareReplay Subscriber #3 received 9</p>\n</blockquote>\n<div class=\"alert is-helpful\">\n<p>To see the unicast / multicast comparison in action, try <live-example name=\"rx-library\"></live-example>.</p>\n</div>\n<h3 id=\"retry-failed-observable\">Retry failed observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a></h3>\n<p>Where the <code>catchError</code> operator provides a simple path of recovery, the <code>retry</code> operator lets you retry a failed request.</p>\n<p>Use the <code>retry</code> operator before the <code>catchError</code> operator.\nIt resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error.\nIf this includes an HTTP request, it will retry that HTTP request.</p>\n<p>The following converts the previous example to retry the request before catching the error:</p>\n<code-example header=\"retry operator\" path=\"rx-library/src/retry-on-error.ts\">\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  map((res: any) => {\n    if (!res.response) {\n      console.log('Error occurred.');\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  retry(3), // Retry up to 3 times before failing\n  catchError(() => of([]))\n);\n\napiData.subscribe({\n  next(x: T) { console.log('data: ', x); },\n  error() { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Do not retry <strong>authentication</strong> requests, since these should only be initiated by user action.\nWe don't want to lock out user accounts with repeated login requests that the user has not initiated.</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">Last reviewed on Fri Aug 25 2023</div>\n</div>\n\n<!-- links to this doc:\n - guide/http-handle-request-errors\n - guide/http-server-communication\n - guide/observables\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/core/Injectable\n - api/platform-browser/animations/async\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#loosely-coupled-apps\n - guide/rx-library#loosely-coupled-transformations\n - guide/rx-library#message-service\n - guide/rx-library#multiple-subscribers\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#subject\n - guide/rx-library#the-rxjs-library\n - guide/understanding-communicating-with-http\n - https://en.wikipedia.org/wiki/Loose_coupling\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://rxjs.dev/api\n - https://rxjs.dev/api/index/function/shareReplay\n - https://rxjs.dev/guide/glossary-and-semantics#multicast\n - https://rxjs.dev/guide/operators\n - https://rxjs.dev/guide/overview\n - https://rxjs.dev/guide/subject\n-->"
}