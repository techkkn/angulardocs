{
  "id": "guide/model-inputs",
  "title": "Model inputs",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"model-inputs\">Model inputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#model-inputs\"><i class=\"material-icons\">link</i></a></h1>\n<p><strong>Model inputs</strong> are a special type of input that enable a component to propagate new values\nback to another component.</p>\n<div class=\"alert is-helpful\">\n<p>Model inputs are currently in <a href=\"/guide/releases#developer-preview\">developer preview</a>.</p>\n</div>\n<p>When creating a component, you can define a model input similarly to how you create a standard\ninput.</p>\n<code-example language=\"typescript\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/model\" class=\"code-anchor\">model</a>, input} from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class CustomCheckbox {\n  // This is a <a href=\"api/core/model\" class=\"code-anchor\">model</a> input.\n  checked = <a href=\"api/core/model\" class=\"code-anchor\">model</a>(false);\n\n  // This is a standard input.\n  disabled = input(false);\n}\n</code-example>\n<p>Both types of input allow someone to bind a value into the property. However, <strong>model inputs allow\nthe component author to write values into the property</strong>.</p>\n<p>In other respects, you can use model inputs the same way you use standard inputs. You can read the\nvalue by calling the signal function, including in reactive contexts like <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> and <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>.</p>\n<code-example language=\"typescript\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/model\" class=\"code-anchor\">model</a>, input} from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'custom-checkbox',\n  template: '&#x3C;div (click)=\"toggle()\"> ... &#x3C;/div>',\n})\nexport class CustomCheckbox {\n  checked = <a href=\"api/core/model\" class=\"code-anchor\">model</a>(false);\n  disabled = input(false);\n\n  toggle() {\n    // While standard inputs are read-only, you can write directly to <a href=\"api/core/model\" class=\"code-anchor\">model</a> inputs.\n    this.checked.set(!this.checked());\n  }\n}\n</code-example>\n<p>When a component writes a new value into a model input, Angular can propagate the new value back\nto the component that is binding a value into that input. This is called <strong>two-way binding</strong> because\nvalues can flow in both directions.</p>\n<h2 id=\"two-way-binding-with-signals\">Two-way binding with signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#two-way-binding-with-signals\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can bind a writable signal to a model input.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...,\n  // `checked` is a <a href=\"api/core/model\" class=\"code-anchor\">model</a> input.\n  // The parenthesis-inside-square-brackets syntax (aka \"banana-in-a-box\") creates a two-way binding\n  template: '&#x3C;custom-checkbox [(checked)]=\"isAdmin\" />',\n})\nexport class UserProfile {\n  protected isAdmin = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(false);\n}\n</code-example>\n<p>In the above example, the <code>CustomCheckbox</code> can write values into its <code>checked</code> model input, which\nthen propagates those values back to the <code>isAdmin</code> signal in <code>UserProfile</code>. This binding keeps that\nvalues of <code>checked</code> and <code>isAdmin</code> in sync. Notice that the binding passes the <code>isAdmin</code> signal\nitself, not the <em>value</em> of the signal.</p>\n<h2 id=\"two-way-binding-with-plain-properties\">Two-way binding with plain properties<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#two-way-binding-with-plain-properties\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can bind a plain JavaScript property to a model input.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...,\n  // `checked` is a <a href=\"api/core/model\" class=\"code-anchor\">model</a> input.\n  // The parenthesis-inside-square-brackets syntax (aka \"banana-in-a-box\") creates a two-way binding\n  template: '&#x3C;custom-checkbox [(checked)]=\"isAdmin\" />',\n})\nexport class UserProfile {\n  protected isAdmin = false;\n}\n</code-example>\n<p>In the example above, the <code>CustomCheckbox</code> can write values into its <code>checked</code> model input, which\nthen propagates those values back to the <code>isAdmin</code> property in <code>UserProfile</code>. This binding keeps\nthat values of <code>checked</code> and <code>isAdmin</code> in sync.</p>\n<h2 id=\"implicit-change-events\">Implicit <code>change</code> events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#implicit-change-events\"><i class=\"material-icons\">link</i></a></h2>\n<p>When you declare a model input in a component or directive, Angular automatically creates a\ncorresponding <a href=\"/guide/inputs-outputs\">output</a> for that model. The output's name is the model\ninput's name suffixed with \"Change\".</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class CustomCheckbox {\n  // This automatically creates an <a href=\"api/core/output\" class=\"code-anchor\">output</a> named \"checkedChange\".\n  // Can be subscribed to using `(checkedChange)=\"handler()\"` in the template.\n  checked = <a href=\"api/core/model\" class=\"code-anchor\">model</a>(false);\n}\n</code-example>\n<p>Angular emits this change event whenever you write a new value into the model input by calling\nits <code>set</code> or <code>update</code> methods.</p>\n<h2 id=\"customizing-model-inputs\">Customizing model inputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#customizing-model-inputs\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can mark a model input as required or provide an alias in the same way as a\n<a href=\"/guide/signal-inputs\">standard input</a>.</p>\n<p>Model inputs do not support input transforms.</p>\n<h2 id=\"differences-between-model-and-input\">Differences between <code><a href=\"api/core/model\" class=\"code-anchor\">model</a>()</code> and <code>input()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#differences-between-model-and-input\"><i class=\"material-icons\">link</i></a></h2>\n<p>Both <code>input()</code> and <code><a href=\"api/core/model\" class=\"code-anchor\">model</a>()</code> functions are ways to define signal-based inputs in Angular, but they\ndiffer in a few ways:</p>\n<ol>\n<li><code><a href=\"api/core/model\" class=\"code-anchor\">model</a>()</code> defines <strong>both</strong> an input and an output. The output's name is always the name of the\ninput suffixed with <code>Change</code> to support two-way bindings. It will be up to the consumer of your\ndirective to decide if they want to use just the input, just the output, or both.</li>\n<li><code><a href=\"api/core/ModelSignal\" class=\"code-anchor\">ModelSignal</a></code> is a <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code> which means that its value can be changed from anywhere\nusing the <code>set</code> and <code>update</code> methods. When a new value is assigned, the <code><a href=\"api/core/ModelSignal\" class=\"code-anchor\">ModelSignal</a></code> will emit\nto its output. This is different from <code><a href=\"api/core/InputSignal\" class=\"code-anchor\">InputSignal</a></code> which is read-only and can only be changed\nthrough the template.</li>\n<li>Model inputs do not support input transforms while signal inputs do.</li>\n</ol>\n<h2 id=\"when-to-use-model-inputs\">When to use model inputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/model-inputs#when-to-use-model-inputs\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use model inputs in components that exist to modify a value based on user interaction.\nCustom form controls, such as a date picker or combobox, should use model inputs for their\nprimary value.</p>\n<p>Avoid using model inputs as a convenience to avoid introducing an additional class property for\ncontaining local state.</p>\n\n  \n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/inputs-outputs\n - /guide/releases#developer-preview\n - /guide/signal-inputs\n - api/core/Component\n - api/core/Directive\n - api/core/InputSignal\n - api/core/ModelSignal\n - api/core/WritableSignal\n - api/core/computed\n - api/core/effect\n - api/core/model\n - api/core/output\n - api/core/signal\n - guide/model-inputs#customizing-model-inputs\n - guide/model-inputs#differences-between-model-and-input\n - guide/model-inputs#implicit-change-events\n - guide/model-inputs#model-inputs\n - guide/model-inputs#two-way-binding-with-plain-properties\n - guide/model-inputs#two-way-binding-with-signals\n - guide/model-inputs#when-to-use-model-inputs\n-->"
}