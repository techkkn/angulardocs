{
  "id": "guide/http-server-communication",
  "title": "HTTP Server communication",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"http-server-communication\">HTTP Server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"callout is-critical\">\n<header>Marked for archiving</header>\n<p>To ensure that you have the best experience possible, this topic is marked for archiving until we determine that it clearly conveys the most accurate information possible.</p>\n<p>In the meantime, this topic might be helpful: <a href=\"guide/understanding-communicating-with-http\">Understanding HTTP</a>.</p>\n<p>If you think this content should not be archived, please file a <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub issue</a>.</p>\n</div>\n<p>Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services.</p>\n<div class=\"alert is-helpful\">\n<p>You can run the <live-example name=\"http\"></live-example> that accompanies this guide.</p>\n<p>The sample app does not require a data server.\nIt relies on the <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular <em>in-memory-web-api</em></a>, which replaces the <em>HttpClient</em> module's <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.\nThe replacement service simulates the behavior of a REST-like backend.</p>\n<p>Look at the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>()</code> method in <code>main.ts</code> to see how it is configured.</p>\n</div>\n<h2 id=\"setup-for-server-communication\">Setup for server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2>\n<p>Before you can use <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, you need to provide the Angular <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> so that it is available for <a href=\"guide/dependency-injection\">dependency injection</a> into the classes that need it.</p>\n<p>Most developers provide the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> when initializing the app with <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> in <code>main.ts</code> using <code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code> exported by <code>app.config.ts</code> as shown in this example:</p>\n<code-example header=\"main.ts (excerpt)\" path=\"http/src/main.ts\" region=\"sketch\">\nimport { <a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a> } from '@angular/platform-browser';\n\nimport {AppComponent} from './app/app.component';\nimport { appConfig } from './app/app.config';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, appConfig);\n\n</code-example>\n<code-example header=\"app.config.ts (excerpt)\" path=\"http/src/app/app.config.ts\" region=\"sketch\">\nimport { <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a> } from '@angular/core';\n\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n  ]\n};\n\n\n</code-example>\n<p>You can then inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service as a dependency of an application class, as shown in the following <code>ConfigService</code> example.</p>\n<code-example header=\"app/config/config.service.ts (excerpt)\" path=\"http/src/app/config/config.service.ts\" region=\"proto\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<h2 id=\"requesting-data-from-a-server\">Requesting data from a server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use the <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> method to fetch data from a server.\nThe asynchronous method sends an HTTP request, and returns an Observable that emits the requested data when the response is received.\nThe return type varies based on the <code>observe</code> and <code>responseType</code> values that you pass to the call.</p>\n<p>The <code>get()</code> method takes two arguments; the endpoint URL from which to fetch, and an <em>options</em> object that is used to configure the request.</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&#x3C;string | number | boolean>},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p>Important options include the <em>observe</em> and <em>responseType</em> properties.</p>\n<ul>\n<li>The <em>observe</em> option specifies how much of the response to return</li>\n<li>The <em>responseType</em> option specifies the format in which to return data</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p>Use the <code>options</code> object to configure various other aspects of an outgoing request.\nIn adding headers, for example, the service set the default headers using the <code>headers</code> option property.</p>\n<p>Use the <code>params</code> property to configure a request with HTTP URL parameters, and the <code>reportProgress</code> option to listen for progress events when transferring large amounts of data.</p>\n</div>\n<p>Applications often request JSON data from a server.\nIn the <code>ConfigService</code> example, the app needs a configuration file on the server, <code>config.json</code>, that specifies resource URLs.</p>\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p>To fetch this kind of data, the <code>get()</code> call needs the following options: <code>{observe: 'body', responseType: 'json'}</code>.\nThese are the default values for those options, so the following examples do not pass the options object.\nLater sections show some of the additional option possibilities.</p>\n<p><a id=\"config-service\"></a></p>\n<p>The example conforms to the best practices for creating scalable solutions by defining a re-usable <a href=\"guide/glossary#service\" title=\"service definition\">injectable service</a> to perform the data-handling functionality.\nIn addition to fetching data, the service can post-process the data, add error handling, and add retry logic.</p>\n<p>The <code>ConfigService</code> fetches this file using the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method.</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&#x3C;Config>(this.configUrl);\n}\n\n</code-example>\n<p>The <code>ConfigComponent</code> injects the <code>ConfigService</code> and calls the <code>getConfig</code> service method.</p>\n<p>Because the service method returns an <code>Observable</code> of configuration data, the component <em>subscribes</em> to the method's return value.\nThe subscription callback performs minimal post-processing.\nIt copies the data fields into the component's <code>config</code> object, which is data-bound in the component template for display.</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nconstructor(private configService: ConfigService) {}\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data => this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p><a id=\"always-subscribe\"></a></p>\n<h3 id=\"starting-the-request\">Starting the request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3>\n<p>For all <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods, the method doesn't begin its HTTP request until you call <code>subscribe()</code> on the observable the method returns.</p>\n<p>This is true for <em>all</em> <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>methods</em>.</p>\n<div class=\"alert is-helpful\">\n<p>You should always unsubscribe from an observable when a component is destroyed.</p>\n</div>\n<p>All observables returned from <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods are <em>cold</em> by design.\nExecution of the HTTP request is <em>deferred</em>, letting you extend the observable with additional operations such as  <code>tap</code> and <code>catchError</code> before anything actually happens.</p>\n<p>Calling <code>subscribe()</code> triggers execution of the observable and causes <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> to compose and send the HTTP request to the server.</p>\n<p>Think of these observables as <em>blueprints</em> for actual HTTP requests.</p>\n<div class=\"alert is-helpful\">\n<p>In fact, each <code>subscribe()</code> initiates a separate, independent execution of the observable.\nSubscribing twice results in two HTTP requests.</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&#x3C;Heroes>('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h3 id=\"requesting-a-typed-response\">Requesting a typed response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3>\n<p>Structure your <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> request to declare the type of the response object, to make consuming the output easier and more obvious.\nSpecifying the response type acts as a type assertion at compile time.</p>\n<div class=\"alert is-important\">\n<p>Specifying the response type is a declaration to TypeScript that it should treat your response as being of the given type.\nThis is a build-time check and doesn't guarantee that the server actually responds with an object of this type.\nIt is up to the server to ensure that the type specified by the server API is returned.</p>\n</div>\n<p>To specify the response object type, first define an interface with the required properties.\nUse an interface rather than a class, because the response is a plain object that cannot be automatically converted to an instance of a class.</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p>Next, specify that interface as the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> call's type parameter in the service.</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.2)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&#x3C;Config>(this.configUrl);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>When you pass an interface as a type parameter to the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method, use the <a href=\"guide/rx-library#operators\">RxJS <code>map</code> operator</a> to transform the response data as needed by the UI.\nYou can then pass the transformed data to the <a href=\"api/common/AsyncPipe\">async pipe</a>.</p>\n</div>\n<p>The callback in the updated component method receives a typed data object, which is easier and safer to consume:</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.2)\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe(data => this.config = { ...data });\n}\n\n</code-example>\n<p>To access properties that are defined in an interface, you must explicitly convert the plain object you get from the JSON to the required response type.\nFor example, the following <code>subscribe</code> callback receives <code>data</code> as an Object, and then type-casts it in order to access the properties.</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n.subscribe(data => this.config = {\n  heroesUrl: (data as any).heroesUrl,\n  textfile:  (data as any).textfile,\n});\n\n</code-example>\n<p><a id=\"string-union-types\"></a></p>\n<div class=\"callout is-important\">\n<header><code>observe</code> and <code>response</code> types</header>\n<p>The types of the <code>observe</code> and <code>response</code> options are <em>string unions</em>, rather than plain strings.</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p>This can cause confusion.\nFor example:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p>In the second case, TypeScript infers the type of <code>options</code> to be <code>{responseType: string}</code>.\nThe type is too wide to pass to <code>HttpClient.get</code> which is expecting the type of <code>responseType</code> to be one of the <em>specific</em> strings.\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> is typed explicitly this way so that the compiler can report the correct return type based on the options you provided.</p>\n<p>Use <code>as const</code> to let TypeScript know that you really do mean to use a constant string type:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n<h3 id=\"reading-the-full-response\">Reading the full response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3>\n<p>In the previous example, the call to <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> did not specify any options.\nBy default, it returned the JSON data contained in the response body.</p>\n<p>You might need more information about the transaction than is contained in the response body.\nSometimes servers return special headers or status codes to indicate certain conditions that are important to the application workflow.</p>\n<p>Tell <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> that you want the full response with the <code>observe</code> option of the <code>get()</code> method:</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&#x3C;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&#x3C;Config>> {\n  return this.http.get&#x3C;Config>(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p>Now <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> returns an <code>Observable</code> of type <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> rather than just the JSON data contained in the body.</p>\n<p>The component's <code>showConfigResponse()</code> method displays the response headers as well as the configuration:</p>\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&#x3C;Config>`\n    .subscribe(resp => {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =>\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p>As you can see, the response object has a <code>body</code> property of the correct type.</p>\n\n  <div class=\"reviewed\">Last reviewed on Wed Aug 16 2023</div>\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/http\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClientModule\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - api/core/ApplicationConfig\n - api/core/Injectable\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - guide/dependency-injection\n - guide/glossary#service\n - guide/http-server-communication#http-server-communication\n - guide/http-server-communication#reading-the-full-response\n - guide/http-server-communication#requesting-a-typed-response\n - guide/http-server-communication#requesting-data-from-a-server\n - guide/http-server-communication#setup-for-server-communication\n - guide/http-server-communication#starting-the-request\n - guide/rx-library#operators\n - guide/understanding-communicating-with-http\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n - https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\n-->"
}