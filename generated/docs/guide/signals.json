{
  "id": "guide/signals",
  "title": "Angular Signals",
  "contents": "\n\n\n\n\n<div class=\"content\">\n  <h1 id=\"angular-signals\">Angular Signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1>\n<p><strong>Angular Signals</strong> is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize\nrendering updates.</p>\n<h2 id=\"what-are-signals\">What are signals?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2>\n<p>A <strong>signal</strong> is a wrapper around a value that can notify interested consumers when that value changes. Signals can contain any value, from simple primitives to complex data structures.</p>\n<p>A signal's value is always read through a getter function, which allows Angular to track where the signal is used.</p>\n<p>Signals may be either <em>writable</em> or <em>read-only</em>.</p>\n<h3 id=\"writable-signals\">Writable signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3>\n<p>Writable signals provide an API for updating their values directly. You create writable signals by calling the <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> function with the signal's initial value:</p>\n<code-example language=\"ts\">\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n\n// Signals are getter functions - calling them reads their value.\nconsole.log('The count is: ' + count());\n</code-example>\n<p>To change the value of a writable signal, you can either <code>.set()</code> it directly:</p>\n<code-example language=\"ts\">\ncount.set(3);\n</code-example>\n<p>or use the <code>.update()</code> operation to compute a new value from the previous one:</p>\n<code-example language=\"ts\">\n// Increment the count by 1.\ncount.update(value => value + 1);\n</code-example>\n<p>Writable signals have the type <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>.</p>\n<h3 id=\"computed-signals\">Computed signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3>\n<p>A <strong>computed signal</strong> derives its value from other signals. Define one using <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> and specifying a derivation function:</p>\n<code-example language=\"typescript\">\nconst count: <a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a>&#x3C;number> = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst doubleCount: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&#x3C;number> = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() => count() * 2);\n</code-example>\n<p>The <code>doubleCount</code> signal depends on <code>count</code>. Whenever <code>count</code> updates, Angular knows that anything which depends on either <code>count</code> or <code>doubleCount</code> needs to update as well.</p>\n<h4 id=\"computed-signals-are-both-lazily-evaluated-and-memoized\">Computed signals are both lazily evaluated and memoized<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4>\n<p><code>doubleCount</code>'s derivation function does not run to calculate its value until the first time <code>doubleCount</code> is read. Once calculated, this value is cached, and future reads of <code>doubleCount</code> will return the cached value without recalculating.</p>\n<p>When <code>count</code> changes, it tells <code>doubleCount</code> that its cached value is no longer valid, and the value is only recalculated on the next read of <code>doubleCount</code>.</p>\n<p>As a result, it's safe to perform computationally expensive derivations in computed signals, such as filtering arrays.</p>\n<h4 id=\"computed-signals-are-not-writable-signals\">Computed signals are not writable signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4>\n<p>You cannot directly assign values to a computed signal. That is,</p>\n<code-example language=\"ts\">\ndoubleCount.set(3);\n</code-example>\n<p>produces a compilation error, because <code>doubleCount</code> is not a <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>.</p>\n<h4 id=\"computed-signal-dependencies-are-dynamic\">Computed signal dependencies are dynamic<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4>\n<p>Only the signals actually read during the derivation are tracked. For example, in this computed the <code>count</code> signal is only read conditionally:</p>\n<code-example language=\"ts\">\nconst showCount = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(false);\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst conditionalCount = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() => {\n  if (showCount()) {\n    return `The count is ${count()}.`;\n  } else {\n    return 'Nothing to see here!';\n  }\n});\n</code-example>\n<p>When reading <code>conditionalCount</code>, if <code>showCount</code> is <code>false</code> the \"Nothing to see here!\" message is returned <em>without</em> reading the <code>count</code> signal. This means that updates to <code>count</code> will not result in a recomputation.</p>\n<p>If <code>showCount</code> is later set to <code>true</code> and <code>conditionalCount</code> is read again, the derivation will re-execute and take the branch where <code>showCount</code> is <code>true</code>, returning the message which shows the value of <code>count</code>. Changes to <code>count</code> will then invalidate <code>conditionalCount</code>'s cached value.</p>\n<p>Note that dependencies can be removed as well as added. If <code>showCount</code> is later set to <code>false</code> again, then <code>count</code> will no longer be considered a dependency of <code>conditionalCount</code>.</p>\n<h2 id=\"reading-signals-in-onpush-components\">Reading signals in <code>OnPush</code> components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2>\n<p>When an <code>OnPush</code> component uses a signal's value in its template, Angular will track the signal as a dependency of that component. When that signal is updated, Angular automatically <a href=\"/api/core/ChangeDetectorRef#markforcheck\">marks</a> the component to ensure it gets updated the next time change detection runs. Refer to the <a href=\"/guide/change-detection-skipping-subtrees\">Skipping component subtrees</a> guide for more information about <code>OnPush</code> components.</p>\n<h2 id=\"effects\">Effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2>\n<p>Signals are useful because they can notify interested consumers when they change. An <strong>effect</strong> is an operation that runs whenever one or more signal values change. You can create an effect with the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> function:</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n  console.log(`The current count is: ${count()}`);\n});\n</code-example>\n<p>Effects always run <strong>at least once.</strong> When an effect runs, it tracks any signal value reads. Whenever any of these signal values change, the effect runs again. Similar to computed signals, effects keep track of their dependencies dynamically, and only track signals which were read in the most recent execution.</p>\n<p>Effects always execute <strong>asynchronously</strong>, during the change detection process.</p>\n<p>Note: the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> API is still in <a href=\"/guide/releases#developer-preview\">developer preview</a> as we work to integrate signal-based reactivity into the core framework.</p>\n<h3 id=\"use-cases-for-effects\">Use cases for effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#use-cases-for-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p>Effects are rarely needed in most application code, but may be useful in specific circumstances. Here are some examples of situations where an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> might be a good solution:</p>\n<ul>\n<li>Logging data being displayed and when it changes, either for analytics or as a debugging tool</li>\n<li>Keeping data in sync with <code>window.localStorage</code></li>\n<li>Adding custom DOM behavior that can't be expressed with template syntax</li>\n<li>Performing custom rendering to a <code>&#x3C;canvas></code>, charting library, or other third party UI library</li>\n</ul>\n<h4 id=\"when-not-to-use-effects\">When not to use effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4>\n<p>Avoid using effects for propagation of state changes. This can result in <code>ExpressionChangedAfterItHasBeenChecked</code> errors, infinite circular updates, or unnecessary change detection cycles.</p>\n<p>Because of these risks, setting signals is disallowed by default in effects, but can be enabled if absolutely necessary.</p>\n<h3 id=\"injection-context\">Injection context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n<p>By default, registering a new effect with the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> function requires an <a href=\"/guide/dependency-injection-context\">injection context</a> (access to the <code>inject</code> function). The easiest way to provide this is to call <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> within a component, directive, or service <code>constructor</code>:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor() {\n    // Register a new effect.\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n      console.log(`The count is: ${this.count()})`);\n    });\n  }\n}\n</code-example>\n<p>Alternatively, the effect can be assigned to a field (which also gives it a descriptive name).</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  \n  private loggingEffect = <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n    console.log(`The count is: ${this.count()})`);\n  });\n}\n</code-example>\n<p>To create an effect outside of the constructor, you can pass an <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> to <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> via its options:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {}\n\n  initializeLogging(): void {\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n      console.log(`The count is: ${this.count()})`);\n    }, {injector: this.injector});\n  }\n}\n</code-example>\n<h3 id=\"destroying-effects\">Destroying effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p>When you create an effect, it is automatically destroyed when its enclosing context is destroyed. This means that effects created within components are destroyed when the component is destroyed. The same goes for effects within directives, services, etc.</p>\n<p>Effects return an <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code> that can be used to destroy them manually, via the <code>.destroy()</code> operation. This can also be combined with the <code>manualCleanup</code> option to create an effect that lasts until it is manually destroyed. Be careful to actually clean up such effects when they're no longer required.</p>\n<h2 id=\"advanced-topics\">Advanced topics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"signal-equality-functions\">Signal equality functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>When creating a signal, you can optionally provide an equality function, which will be used to check whether the new value is actually different than the previous one.</p>\n<code-example language=\"ts\">\nimport _ from 'lodash';\n\nconst data = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(['test'], {equal: _.isEqual});\n\n// Even though this is a different array instance, the deep equality\n// function will consider the values to be equal, and the <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> won't\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> any updates.\ndata.set(['test']);\n</code-example>\n<p>Equality functions can be provided to both writable and computed signals.</p>\n<h3 id=\"reading-without-tracking-dependencies\">Reading without tracking dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n<p>Rarely, you may want to execute code which may read signals in a reactive function such as <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> or <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> <em>without</em> creating a dependency.</p>\n<p>For example, suppose that when <code>currentUser</code> changes, the value of a <code>counter</code> should be logged. Creating an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> which reads both signals:</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n  console.log(`User set to `${currentUser()}` and the counter is ${counter()}`);\n});\n</code-example>\n<p>This example logs a message when <em>either</em> <code>currentUser</code> or <code>counter</code> changes. However, if the effect should only run when <code>currentUser</code> changes, then the read of <code>counter</code> is only incidental and changes to <code>counter</code> shouldn't log a new message.</p>\n<p>You can prevent a signal read from being tracked by calling its getter with <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code>:</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n  console.log(`User set to `${currentUser()}` and the counter is ${<a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(counter)}`);\n});\n</code-example>\n<p><code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> is also useful when an effect needs to invoke some external code which shouldn't be treated as a dependency:</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() => {\n  const user = currentUser();\n  <a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(() => {\n    // If the `loggingService` reads signals, they won't be counted as\n    // dependencies of this effect.\n    this.loggingService.log(`User set to ${user}`);\n  });\n});\n</code-example>\n<h3 id=\"effect-cleanup-functions\">Effect cleanup functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Effects might start long-running operations, which should be cancelled if the effect is destroyed or runs again before the first operation finished. When you create an effect, your function can optionally accept an <code>onCleanup</code> function as its first parameter. This <code>onCleanup</code> function lets you register a callback that is invoked before the next run of the effect begins, or when the effect is destroyed.</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>((onCleanup) => {\n  const user = currentUser();\n\n  const timer = setTimeout(() => {\n    console.log(`1 second ago, the user became ${user}`);\n  }, 1000);\n\n  onCleanup(() => {\n    clearTimeout(timer);\n  });\n});\n</code-example>\n\n  <div class=\"reviewed\">Last reviewed on Wed Jun 21 2023</div>\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectorRef#markforcheck\n - /guide/change-detection-skipping-subtrees\n - /guide/dependency-injection-context\n - /guide/releases#developer-preview\n - api/animations/trigger\n - api/core/Component\n - api/core/EffectRef\n - api/core/Injector\n - api/core/Signal\n - api/core/WritableSignal\n - api/core/computed\n - api/core/effect\n - api/core/signal\n - api/core/untracked\n - guide/signals#advanced-topics\n - guide/signals#angular-signals\n - guide/signals#computed-signal-dependencies-are-dynamic\n - guide/signals#computed-signals\n - guide/signals#computed-signals-are-both-lazily-evaluated-and-memoized\n - guide/signals#computed-signals-are-not-writable-signals\n - guide/signals#destroying-effects\n - guide/signals#effect-cleanup-functions\n - guide/signals#effects\n - guide/signals#injection-context\n - guide/signals#reading-signals-in-onpush-components\n - guide/signals#reading-without-tracking-dependencies\n - guide/signals#signal-equality-functions\n - guide/signals#use-cases-for-effects\n - guide/signals#what-are-signals\n - guide/signals#when-not-to-use-effects\n - guide/signals#writable-signals\n-->"
}